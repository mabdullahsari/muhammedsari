PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS "blogging_posts" ("id" integer primary key autoincrement not null, "author_id" integer not null, "slug" varchar not null, "title" varchar not null, "body" text not null default '', "summary" varchar not null default '', "state" varchar not null default 'draft', "published_at" datetime, "created_at" datetime, "updated_at" datetime);
INSERT INTO blogging_posts VALUES(1,1,'controllers-and-their-true-purpose','Controllers and their true purpose',replace('Last week, [I tweeted](https://twitter.com/mabdullahsari/status/1653718721293172738) about how my controllers look in my own applications and how I generally approach them. The tweet quickly went viral and gained a lot of attention, but unfortunately for all the wrong reasons. That''s why in this blog post, I''d like to shed some light on what I was actually aiming for and explain what a (UI) `Controller` is supposed to be in general.\n\n*The code examples are from the source code of [this blog](https://github.com/mabdullahsari/muhammedsari). Please head over to the repository to see how the different pieces click together.*\n\n## Refactoring the (UI) Controller\n\nThe discussions below the tweet were mainly about [**Dependency Injection (DI)**](https://martinfowler.com/articles/injection.html#FormsOfDependencyInjection) vs. [**Service Location (SL)**](https://martinfowler.com/articles/injection.html#UsingAServiceLocator). However, this was not the point of the tweet in any way, shape or form. So let''s take a minute to refactor the code to make use of SL:\n\n```php\nfinal readonly class SubmitContactFormController\n{\n    public function __invoke(SubmitRequest $request): RedirectResponse\n    {\n        $command = new ContactMuhammed(\n            $request->input(''email''),\n            $request->ip(),\n            $request->input(''message''),\n            $request->input(''name''),\n        );\n        \n        Bus::dispatch($command);\n\n        return Redirect::route(''contact'', [''success'' => true]);\n    }\n}\n```\n\nThe steps we took are:\n\n- The form validation rules have been moved to a `FormRequest` class\n- The `Bus` component is now used through a static container proxy\n- The `ResponseFactory` component is now used through a static container proxy\n\nNow that we have successfully refactored the (UI) `Controller` to make use of SL, we can start talking about its intended purpose.\n\n## The (UI) Controller as the Composition Root\n\nThe (UI) `Controller` actually has a distinguished role during our application''s lifecycle. The web server usually receives a request, forwards it to a PHP process which boots the framework and finally the framework forwards the request to us: the (UI) `Controller`. Based on this, we can establish the fact that a (UI) `Controller` is the [Composition Root](https://blog.ploeh.dk/2011/07/28/CompositionRoot/) of *our application*. It is the first piece of code that is called which we have full control over.\n\nThis is the reason why I don''t really mind whether you make use of DI or SL in your (UI) `Controller`. The object graph has to be composed somehow, so feel free to use either of them.\n\n## Why do you keep prefixing "UI" to Controller?\n\nI''m glad you asked. That''s because I''d like to put emphasis on this very fact: a UI `Controller`s task is to orchestrate the `Request`-`Response` lifecycle which is usually initiated by a user *through a user interface*. The keyword here is *orchestration*. Its primary goal should be to handle UI related concerns such as form validation, rendering a view, creating a redirect etc. If the `Controller` holds onto its true purpose, then it doesn''t really matter whether it''s 10 lines long, or 90 lines long. It should handle the UI concerns, and handle them well. Everything else does not belong inside a `Controller` and should be forwarded to the `Application`.\n\nThis might sound a bit counter-intuitive now, but a CLI `Command` is a `Controller` as well. It also takes user input and does something with it, albeit in a slightly different manner. Livewire components? Yep, they''re `Controller`s as well. Just dynamic ones leveraging XHR on the front-end.\n\n## Forwarding messages to the application\n\nWhen a request comes into our `Controller`, something must happen. Someone tried to invoke some particular behavior in our system. The intent of the user is represented by the command object, or in other words the application is represented by this one single command object:\n\n```php\n$command = new ContactMuhammed(\n    $request->input(''email''),\n    $request->ip(),\n    $request->input(''message''),\n    $request->input(''name''),\n);\n```\n\nThe `Controller`s relationship with the `Application` starts and ends here. It forwards the message, in this case the command, to the application and calls it a day. `ContactMuhammed` is the contract between the `Controller` and the `Application` handling this command. As long as the contract is respected and stays intact, everything will keep functioning without a hitch. This is what one calls "loose coupling" and it was *the entire point* of my original tweet.\n\nNow, I am deliberately keeping the `Application` as abstract as possible because the implementation details can vary from person to person and from codebase to codebase. Some people like implementing Clean Architecture (I call that the "Baklava" Architecture, mmm), some people like to vertically slice their applications and some people like to mix and match.\n\n## Isn''t that the "Action" pattern?\n\nNo, it is not. The `Action` pattern is a rechristened version of the [GoF Command pattern](https://refactoring.guru/design-patterns/command) which represents a self-handling command. \n\nIf we take a closer look at `ContactMuhammed`, we can see that there''s 0 business logic embedded inside of it:\n\n```php\nfinal readonly class ContactMuhammed implements ShouldQueue\n{\n    public function __construct(\n        public string $email,\n        public string $ipAddress,\n        public string $message,\n        public string $name,\n    ) {}\n}\n```\n\n`ContactMuhammed` is what we could call an [EIP Command](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CommandMessage.html). It represents the intent of the user, and only that. Nothing more. Eagle-eyed readers may already have noticed that is also in fact a `Data Transfer Object`, albeit a more specific one.\n\n## What about the query side of things?\n\nIt''s true that we have only talked about commands thus far. However, querying some data and returning that to the user doesn''t change anything regarding the `Controller`s design. While commands *could* be handled asynchronously by the `Application`, queries are typically synchronous and thus we are *temporally coupled* to our `Application`.\n\nThis is the logic that is responsible for rendering this very blog post:\n\n```php\nfinal readonly class ReadBlogPostController\n{\n    public function __construct(\n        private GetSinglePost $posts, \n        private ResponseFactory $response,\n    ) {}\n\n    public function __invoke(string $slug): Response\n    {\n        $post = $this->posts->findBySlug($slug);\n\n        return $this->response->view(''read-blog-post'', $post->toArray());\n    }\n}\n```\n\n`GetSinglePost` is the contract between the `Controller` and our `Application`. As long as it keeps returning a `Post` view model, everything will stay functional and nothing will break.\n\n## Summary\n\n- The `Controller`s main task is to handle the User Interface\n- The `Controller` should delegate everything else to the application\n- The `Controller` should return user friendly error messages in case of failures\n\n[Join the discussion on X (formerly Twitter)!](https://twitter.com/mabdullahsari/status/1657413267772391424) I''d love to know what you thought about this blog post.\n\nThanks for reading!','\n',char(10)),'What are controllers? What''s their intended purpose? Can we put business logic in them? How many lines of code should they contain? Let''s find out.','published','2023-05-13 15:51:30','2023-05-11 19:09:18','2023-09-14 11:31:38');
INSERT INTO blogging_posts VALUES(2,1,'repositories-and-their-true-purpose','Repositories and their true purpose',replace('Lately, posts and tweets regarding the `Repository` pattern have made yet another resurgence. It''s seemingly impossible to predict when, where or why such "spicy topics" will rear their heads... However, the spark that causes the ignition of these "hot topics" is almost always the following question (or something similar):\n\n> How many times have you replaced the underlying database implementation because of your use of the Repository pattern?\n\n*— Random Techfluencer*\n\nThat''s why, in this blog post, I''d like to provide some further clarity regarding this totally misunderstood software design pattern and why the #1 argument (the question above) against its use is actually insignificant and *almost irrelevant*.\n\n## Defining a Repository\n\nFirst and foremost, let''s start off by defining what a `Repository` actually is. The `Repository` pattern is defined as follows in [PoEAA](https://martinfowler.com/eaaCatalog/repository.html):\n\n> Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects.\n\nIt is of paramount importance that we establish the facts below before moving on to the other sections.\n\n### (...) accessing domain objects\n\nDomain objects are actors in the domain layer that possess an authoritative set of business capabilities for carrying out certain tasks. These capabilities or behaviors are exposed as public methods on said actors in order to make consistent state changes. Domain objects are also known as write models, entities or as aggregates in [DDD](https://www.youtube.com/watch?v=8Z5IAkWcnIw) lingo.\n\n*Note: Aggregates and their exact purpose is out of scope for this blog post. However, I can recommend [this short, concise write-up by Shawn McCool](https://shawnmc.cool/2023-05-11_aggregates-for-those-familiar-with-activerecord) if you''d like to learn more about them.*\n\nYou''ve probably heard the notion "business logic" numerous times by now. Well, these models are the ones that actually determine what that "business logic" should entail.\n\n### (...) collection-like interface (...)\n\nIn an ideal world, a persistence layer for the entities would not be needed as everything can be added and removed from an in-memory collection. For example:\n\n```php\nfinal class Users\n{\n    private array $users;\n\n    private function __construct(User ...$users)\n    {\n        $this->users = $users;\n    }\n\n    public static function empty(): self\n    {\n        return new self();\n    }\n\n    public function add(User $user): void\n    {\n        $this->users[$user->id()->asString()] = $user;\n    }\n\n    public function find(UserId $id): User\n    {\n        return $this->users[$id->asString()] \n            ?? throw CouldNotFindUser::becauseItIsMissing();\n    }\n\n    public function remove(User $user): void\n    {\n        unset($this->users[$user->id()->asString()]);\n    }\n}\n```\n\nUnfortunately, the real world is often rather different from the ideal world. PHP has its (in)famous request-response lifecycle which results in the loss of every bit of relevant context once an incoming request has been handled and a response has been sent to the client. A `Repository` assists us in approximating this ideal world by giving the *illusion* that we can perform our operations on in-memory collections that seemingly live forever. An example `Repository` could be:\n\n```php\ninterface UserRepository\n{\n    public function find(UserId $id): User;\n    public function save(User $user): void;\n    public function remove(User $user): void;\n}\n```\n\nPlease take note of the minimal signature of this interface. \n\n## Collection-oriented vs. persistence-oriented\n\n[Vaughn Vernon](https://vaughnvernon.com/), the author of The Big Red Book ([iDDD](https://kalele.io/books/)), mentions collection-oriented and persistence-oriented `Repository` implementations in Chapter 12. I''d like to briefly mention this fact, because this is the reason why you might see different "flavors" of `Repository` implementations in the wild. The difference lies primarily in the semantics. \n\nA collection-oriented design can be considered a traditional design because of adherance to an in-memory collection''s standard interface.\n\n```php\n$users->add($user);\n```\n\n A persistence-oriented design is also known as a save-based `Repository`.\n\n```php\n$users->save($user);\n```\n\nPersonally, I prefer the persistence orientation due to PHP''s ephemeral nature.\n\n## Authoritative collection\n\nA `Repository` is the authoritative collection for interacting with a specific type of entity. It can be used to store, filter, retrieve and remove entities based on the application''s needs. In other words, we delegate the task for remembering the existence of a certain entity to the `Repository`. \n\n### Explained by example: publishing a post\n\nLet''s take a look at a use case to solidify our understanding. \n\n```php\nfinal readonly class PublishPostHandler\n{\n    public function __construct(\n        private PostRepository $posts,\n    ) {}\n\n    public function handle(PublishPost $command): void\n    {\n        $post = $this->posts->find($command->id);\n        \n        $post->publish();\n        \n        $this->posts->save($post);\n    }\n}\n```\n\nThis use case assumes that a `Post` entity must already exist in order to publish it. Since the `PostRepository` is the authoritative collection for dealing with these `Post` entities, we can ask it to provide us with a `Post` entity for the given `PostId`:\n\n```php\n$post = $this->posts->find($command->id);\n```\n\nOnce we''ve received a `Post` instance, we carry on with the task we were supposed to carry out in the first place: \n\n```php\n$post->publish();\n```\n\nThe `publish` method exposes the behavior that is responsible for actually "publishing a blog post". If we dig a little deeper, we can see that it is also enforcing crucial [invariants](https://codeopinion.com/aggregate-design-using-invariants-as-a-guide):\n\n```php\npublic function publish(): void\n{\n    if ($this->isPublished()) {\n        throw CouldNotPublish::becauseAlreadyPublished();\n    } elseif ($this->summary->isEmpty()) {\n        throw CouldNotPublish::becauseSummaryIsMissing();\n    } elseif ($this->body->isEmpty()) {\n        throw CouldNotPublish::becauseBodyIsMissing();\n    } elseif ($this->tags->isEmpty()) {\n        throw CouldNotPublish::becauseTagsAreMissing();\n    }\n\n    // omitted for brevity\n}\n```\n\nIf everything goes well, we move on and tell the `PostRepository` to remember the `Post` in its *current state*:\n\n```php\n$this->posts->save($post);\n```\n\nNext time we interact with the `PostRepository` and ask for the exact same entity, we can expect to receive the `Post` in this state. The `PostRepository` will ensure that this condition is met at *all times*. This is a `Repository`''s single most important *responsibility*, after all.\nThe `PostRepository` clearly defines the boundaries around the application service which also yields a lot of benefits such as isolated testability and purposefully keeping the (core) domain oblivious to its surroundings.\n\n## Persistence agnosticity\n\nLet''s quickly recall *Random Techfluencer*''s original statement:\n\n> How many times have you replaced the underlying database implementation because of your use of the Repository pattern?\n\n*Random Techfluencer* is actually discouraging the use of the `Repository` because "how many times are you going to swap out data sources?".\n\nNow, please let me make something absolutely clear. The swapping of the data source is a puny argument whether you use it to *promote* **or** *obstruct* the use of the `Repository`. It does *not* matter which camp (pro / contra) you belong to. Do you really want to think about swapping out data sources as you are designing the domain? This kind of thinking is - in my humble opinion - flawed.\n\n### Ad hoc persistence swapping\n\nThe fact that you can easily swap out data sources later on is nothing but a *bonus* that you are awarded by carefully placing boundaries around your application. This is "boundaries in software design 101" and trying to use this as the main selling point every single time does noone any good.\n\nYou can start out your application by using simple JSON files on disk and gradually evolve towards "beefier" solutions as different needs emerge. \n\n```php\nfinal class UserRepositoryUsingJsonFilesOnDisk implements UserRepository\n{\n    public function add(User $user): void\n    {\n        // add a user\n    }\n\n    public function find(UserId $id): User\n    {\n        // find a user\n    }\n\n    public function remove(User $user): void\n    {\n        // remove a user... you get the point\n    }\n}\n```\n\nDifferent features can evolve independent of each other and infrastructural costs can be kept to a minimum. Why use an expensive cloud-hosted solution *for everything* if 90% of the other features are well-suited for a storage mechnism like SQLite? Why keep using MySQL *for every single feature* if 10% of the features are well-suited for Elastic and Riak?\n\n## Testability\n\nIn a similar vein to persistence agnosticity, testability is another *bonus* we are awarded by carefully placing boundaries around our application.\nThe real thing can keep using a `DoctrinePostRepository` while the tests can use an `InMemoryPostRepository` allowing us to have lightning fast tests.\n\nThe test for the "publishing a blog post" use case, that was mentioned previously, might look as follows:\n\n```php\n// Arrange\n$post = $this->aPost([''id'' => PostId::fromInt($id = 123)]); // draft\n$repository = $this->aPostRepository([$post]); // in-memory repository\n$handler = new PublishPostHandler($repository);\n\n// Act\n$handler->handle(new PublishPost($id));\n\n// Assert\n$this->assertTrue($repository->wasSaved($post));\n$this->assertTrue($post->isPublished());\n```\n\nIn this example, we''re testing the application service represented by the command handler. We don''t need to test that the repository stored the data in the database or wherever else. We need to test the specific behavior of the handler, which is to publish the `Post` object and pass it into the repository to preserve its state.\n\n"This is not a big deal", you might rightfully say, "I can just hit persistence during my tests every single time".\nI''m not sure if you know someone who''s worked on a project whose test suite was completely shut down because it just took way too long to go through the entire thing? I do know someone and that person is unfortunately me. Integration and System / E2E tests definitely have their place, but the sheer velocity and the fast feedback loop of unit tests is still highly desirable.\n\n## Alleviating performance issues\n\nPerformance is another reason as to why a `Repository` is often employed. It''s not an uncommon scenario to have millions of instances of a certain entity type so we are kind of forced to offload this to an external data store. \n\nAssume the following excerpt from an imaginary `User` entity:\n\n```php\npublic function changeEmail(Email $newEmail, Users $allUsers)\n{\n    if ($allUsers->findByEmail($newEmail)) {\n        throw new CannotChangeEmail::becauseEmailIsAlreadyTaken();\n    }\n    \n    $this->email = $newEmail;\n}\n```\n\nThe `changeEmail` behavior depends on a `Users` collection to determine whether the new email address can be used. The (imaginary) domain experts told us that an email change may not happen as long as there is another user in possession of that new email address. \n\nThis code will work just fine until we hit a certain amount of users. The collection''s sheer size will become a bottleneck for the lookups that must be performed in order to enforce invariants. We could fix this problem by injecting a `UserRepository` instead of passing every single `User` in existence via an in-memory `Users` collections. \n\n```php\npublic function changeEmail(Email $newEmail, UserRepository $users)\n{\n    if ($users->findByEmail($newEmail)) {\n        throw new CannotChangeEmail::becauseEmailIsAlreadyTaken();\n    }\n    \n    $this->email = $newEmail;\n}\n```\n\nThis way, the domain model will still be responsible for enforcing the invariants; but we had to trade the [domain model''s purity](https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness/) off against performance. Nonetheless, this is most definitely an acceptable trade-off.\n\n## Command Query Responsibility Segregation\n\n"I thought this blog post was about the `Repository` pattern? What''s the deal with [CQRS](https://web.archive.org/web/20120419072250/https://goodenoughsoftware.net/2012/03/02/cqrs) all of a sudden..?" Please let me explain.\n\n### Write models (commands)\n\nUntil now, we''ve seen how the `Repository` helps us with dealing with the lifecycle of *domain objects*. We established the fact that these domain objects are also known as write models / entities / aggregates that are responsible for performing state changes in a consistent manner. In other words, the aggregates represent a consistency boundary that must follow the business rules and apply them at all times in order to stay consistent.\nNaturally, these state changes always occur as a result of a command entering an application. \n\n### Read models (queries)\n\nWe need to ask ourselves whether we actually need to perform state changes or just need some data. Why would we "just need some data"? Well... you guessed it right: for **queries**. [CQRS](https://web.archive.org/web/20120419072250/https://goodenoughsoftware.net/2012/03/02/cqrs) is a dead simple pattern for separating the logical models for read and write concerns—that''s it. It has nothing to do with event sourcing / eventual consistency / separated data stores etc. These buzzwords are often thrown into the mix by people who don''t really know what they''re talking about. Use cases that involve queries will benefit from better optimized, dedicated *read models*.\n\n### Explained by example: displaying a table of invoices\n\nLet''s take a look at a use case to solidify our understanding. \n\n```php\nfinal readonly class ViewInvoicesController\n{\n    public function __construct(\n        private GetMyInvoices $query,\n        private Factory $view,\n    ) {}\n\n    public function __invoke(Request $request): View\n    {\n        $invoices = $this->query->get();\n\n        return $this->view->make(''view-invoices'', [\n            ''invoices'' => $invoices,\n        ]);\n    }\n}\n```\n\nThis use case is responsible for *displaying* a table of invoices to the user. All of the magic happens during this line:\n\n```php\n$invoices = $this->query->get();\n```\n\nThe query handler `GetMyInvoices` provides us with a collection of `InvoiceSummary` **read models** dedicated for this purpose. A single `InvoiceSummary` instance might look as follows:\n\n```php\nfinal readonly class InvoiceSummary\n{\n    public function __construct(\n        public int $amountOfDiscountsApplied,\n        public string $paymentTerms,\n        public string $recipient,\n        public int $totalAmountInCents,\n    ) {}\n}\n```\n\nEagle-eyed readers may already have noticed that this is in fact a `Data Transfer Object`. `DTO`s typically contain only data and no behavior. However, this is exactly what we want: a *read model* dedicated to the purpose of displaying some relevant data to the user. You may already have noticed that this model doesn''t contain any information regarding the individual invoice line items; and this is totally on purpose! A table view cannot display individual invoice line items. Thus, our *read model* is optimized and carefully crafted for this exact use case.\n\nThe write model might look like this (courtesy of [Shawn McCool](https://shawnmc.cool/2023-05-11_aggregates-for-those-familiar-with-activerecord)):\n\n```php\nfinal readonly class LineItem\n{\n    public __construct(private bool $isDiscount) {}\n\n    public function isDiscount(): bool\n    {\n        return $this->isDiscount;\n    }\n}\n\nfinal class Invoice\n{\n    private RecipientName $recipientName;\n	\n    private LineItems $lineItems;\n\n    public function __construct(\n        RecipientName $recipientName\n    ) {\n        $this->recipientName = $recipientName;\n        $this->lineItems = LineItems::empty();\n    }\n\n    public function addLineItem($item): void\n    {\n        if (\n            $item->isDiscount()\n            && $this->lineItems->hasDiscountedItem()\n        ) {\n            throw CannotAddLineItem::multipleDiscountsForbidden($item);\n        }\n\n        $this->lineItems->add($item);\n    }\n}\n```\n\nSo to be more precise, *we went directly to the data source itself instead of trying to shoe-horn a use case into an Invoice write model that is totally not designed to fulfill a specialized query-based, read use case*. Why carry the burden of instantiating this complex write model in order to fulfill a use case that won''t even need any of the line items that are defined within this write model? The write model *requires* all of the line items in order to keep its state consistent, but the read model does not.\n\n## Where does a Repository belong to: application or domain layer?\n\nWe can consider the application layer as the specific layer within a multi-layered architecture that handles the implementation details unique to the application, such as database persistence, internet protocol knowledge (sending emails, API interactions), and more. Now, let''s establish the domain layer as the layer in a multi-layered architecture that primarily deals with business rules and business logic.\n\nGiven these definitions, where exactly do our repositories fit into the picture? Let''s revisit a variation of a source code example we discussed earlier:\n\n```php\nfinal class InMemoryUserRepository implements UserRepository\n{\n    private array $users = [];\n\n    public function find(UserId $id): User\n    {\n        return $this->users[$id->asString()]\n            ?? throw CouldNotFindUser::becauseItIsMissing();\n    }\n\n    public function remove(User $user): void\n    {\n        unset($this->users[$user->id()->asString()]);\n    }\n\n    public function save(User $user): void\n    {\n        $this->users[$user->id()->asString()] = $user;\n    }\n}\n```\n\nI''m observing numerous implementation details that can be regarded as "noise". Therefore, this implementation detail belongs in the application layer. Let''s remove this noise and see what we are left with:\n\n```php\nfinal class InMemoryUserRepository implements UserRepository\n{\n    private array $users = [];\n\n    public function find(UserId $id): User\n    {\n    }\n\n    public function remove(User $user): void\n    {\n    }\n\n    public function save(User $user): void\n    {\n    }\n}\n```\n\nDoes this actually remind you of something? Perhaps this?\n\n```php\ninterface UserRepository\n{\n    public function find(UserId $id): User;\n    public function save(User $user): void;\n    public function remove(User $user): void;\n}\n```\n\nPlacing an interface at layer boundaries entails the following implication: While the interface itself can encompass domain-specific concepts, its implementation should not. In the context of repository interfaces, **they belong to the domain layer**. The *implementation* of repositories belongs to the application layer. Consequently, we can freely utilize type-hinting for repositories within the domain layer, without any need for dependencies on the application layer.\n\n## Various other benefits\n\nBelow is a non-exhaustive list of various other benefits a `Repository` can bring along with it:\n\n- Access to the decorator pattern to add additional concerns without having to modify the domain e.g. to employ something like [hashids](https://hashids.org/) for YouTube-like identifiers.\n- The ability to implement the [transactional outbox pattern](https://microservices.io/patterns/data/transactional-outbox.html) for mission-critical, event-driven systems.\n- Centralizing access / persistence logic if the application relies on data models primarily and you''d like to migrate away.\n- Automatically adding audit information alongside the persisted entity.\n\n...\n\n## Wrap-up\n\nThat was a lot to go through! Thanks for sticking around until the end. \n\nBasically, if we were to enumerate all of the benefits for using a `Repository`, persistence agnosticity would definitely come last or at the very least be close to being last. Therefore, I hope that we can stop taking concepts at face value and actually examine them a little deeper to unearth the actual use cases and the contexts in which they''re supposed to be used. \n\n- `Repository` is the authoritative actor for safely collecting and preserving entities and managing their lifecycle\n- The ability to swap underlying the persistence driver is a mere *bonus*\n- The ability to easily test without an actual persistence driver is a mere *bonus*\n- Do use a `Repository` for your write models\n- Don''t use a `Repository` for your read models: go to the data source instead\n\n[Join the discussion on X (formerly Twitter)!](https://twitter.com/mabdullahsari/status/1661288614263750656) I''d love to know what you thought about this blog post.\n\nThanks for reading!','\n',char(10)),'What is the repository pattern? What is it good for? Why''d we use it if we''re never going to change the RDBMS? Would it be considered over-engineering if we did use one? Let''s find out.','published','2023-05-24 08:29:40','2023-05-20 13:52:01','2023-09-14 11:31:28');
INSERT INTO blogging_posts VALUES(3,1,'unorthodox-eloquent','Unorthodox Eloquent',replace('Eloquent is a razor-sharp tool that is adored by many. It allows you to carry out database operations with ease while maintaining an easy-to-use API. Implementing the Active Record (AR) pattern, as decribed by [Fowler in PoEAA](https://www.martinfowler.com/eaaCatalog/activeRecord.html), it is one of the best AR implementations that is available today.\n\nIn this blog post, I''d like to go over a few tips and tricks I have learned along the way while experimenting with different options. For example, have you ever considered sharing your eager loads one way or another? No? Well, then I''m pretty sure you''ll learn at least a thing or two so make sure you stick around until the end!\n\n*Like every tool in existence, Eloquent comes with its own set of trade-offs. As responsible developers, we should always be aware of the things we are trading off against. If you''d like to learn more about AR and its design philosophy, I highly recommend this [article by Shawn McCool](https://shawnmc.cool/2023-02-13_active-record-how-we-got-persistence-perfectly-wrong).*\n\n## Quick navigation\n\n* [Tappable scopes](#tappable-scopes)\n* [Not-so-global global scopes](#not-so-global-global-scopes)\n* [Phantom properties](#phantom-properties)\n* [Fluent query objects](#fluent-query-objects)\n* [Sharing eager loads](#sharing-eager-loads)\n* [Invokable accessors](#invokable-accessors)\n* [Multiple read models for the same table](#multiple-read-models-for-the-same-table)\n* [WithoutRelations for queue performance](#codewithoutrelationscode-for-queue-performance)\n\n## Tappable scopes\n\nTraditionally, reusable query scopes have always been defined within the target model itself using the magical `scopeXXX` syntax, macros or a dedicated `Builder` class. The problem with the first two approaches is that they both rely on opaque runtime magic making it (almost) impossible to receive IDE assistance. Even worse, naming clashes can occur in the case of macro registrations. However, there is a fourth—and in my opinion superior—approach: tappable scopes. Tappable scopes is one of those hidden gems that is extremely valuable, but at the same time completely unknown to the masses because [it is not documented anywhere](https://laravel.com/docs/10.x/eloquent#query-scopes).\n\n### Explained by example\n\nLet''s take the following `Controller` method as an example:\n\n```php\npublic function index(): Collection\n{\n    return Company::query()\n        ->oldest()\n        ->whereNull(''user_id'')\n        ->whereNull(''verified_at'')\n        ->get();\n}\n```\n\nWe can see that it applies some conditions to the `Builder` instance, and returns the result as-is without any transformation. While this is a perfectly valid way to write a query, it leaks internals and the where clauses do not tell us anything about the domain language. Perhaps the requirement was: "Create an endpoint that returns the oldest orphaned & unverified companies". Orphaned in this case means that a company was abandoned during registration and it is the notion that our domain experts use. Thus we can do much better:\n\n```php\npublic function index(): Collection\n{\n    return Company::query()\n        ->oldest()\n        ->tap(new Orphan())\n        ->tap(new Unverified())\n        ->get();\n}\n```\n\nThis almost reads like the requirement itself, right? Now, if we quickly take a gander at one of these tappable scopes:\n\n```php\nfinal readonly class Orphan\n{\n    public function __invoke(Builder $builder): void\n    {\n        $builder->whereNull(''user_id'');\n    }\n}\n```\n\nThat''s it! This simplicity allows us to compose queries in any way, shape or form we''d like and not be restricted to using a particular trait or something that pollutes our Eloquent models. \n\nNow imagine that a new requirement comes in that demands a brand new endpoint that should list orphaned members that belong to a certain company. At this point we might start sweating because there is no commonality between a `Company` and a `Member`, but don''t fret! Tappable scopes to the rescue! Let''s just reuse the scope and call it a day:\n\n```php\npublic function index(Request $request): Collection\n{\n    return Member::query()\n        ->whereBelongsTo($request->company)\n        ->tap(new Orphan())\n        ->get();\n}\n```\n\n**This** is the power of tappable scopes. I think it should also be mentioned that this example requires both models to possess the concept of being "orphaned" , which is the state of abandonment after an initiated registration process, as signalled by a nullable `user_id` column. The registration is complete once a user is linked to all models. Needless to say, you can''t just go and use any scope with any model. It must be supported by the backing database table.\n\n### Specification pattern note\n\nHave you ever heard about the [Specification pattern](https://www.martinfowler.com/apsupp/spec.pdf) and tried applying it [dogmatically](https://laracasts.com/series/design-patterns-in-php/episodes/6)? As you may know, dogma is the root of all evil. This way of applying query constraints offers the best of many worlds.\n\n### Are you a package author?\n\nTappable scopes are especially useful for package authors who''d like to share reusable scopes alongside their packages. Let''s take [laravel-adjacency-list](https://github.com/staudenmeir/laravel-adjacency-list) as an example. [`scopeIsRoot`](https://github.com/staudenmeir/laravel-adjacency-list/blob/master/src/Eloquent/Traits/HasRecursiveRelationshipScopes.php#L94) could be refactored as follows:\n\n```php\nfinal readonly class IsRoot\n{\n    public function __invoke(Builder $builder): void\n    {\n        $builder->whereNull(''parent_id'');\n    }\n}\n```\n\nThis approach also solves the [issue of clashing method and scope names](https://github.com/staudenmeir/laravel-adjacency-list/pull/84#issuecomment-1037416147), thanks to simply avoiding the ancient magics that are still available in the framework from the early days. All in all, the utilization of tappable scopes yields a net positive for 90% of use cases out there.\n\n## Not-so-global global scopes\n\nI know that the title doesn''t make a lot of sense when read out of context, but please bear with me. Every now and then a couple of [posts regarding global scopes appear](https://twitter.com/stef_r/status/1627692788673392641) on my X (formerly Twitter) timeline. The general sentiment is always along the lines of "[global scopes are bad, local scopes are good](https://twitter.com/djgeisi/status/1648643569027100672)". The reason for this is that the [Laravel documentation on global scopes](https://laravel.com/docs/10.x/eloquent#global-scopes) does them a huge disfavor by making it look like the documented way of applying global scopes is the *only way*, but nothing could be further from the truth. \n\nA while ago, I was thinking about this common complaint and then it struck me: what happens if you flout this convention? I took a gander at the global scopes API and quickly realized that it was in fact not a requirement to declare the scopes within your Eloquent models'' `booted` lifecycle method. As a matter of fact, there are no restrictions at all! They can be applied in a `ServiceProvider`, `Middleware`, `Job` etc. the possibilities are endless. The best use, however, is—in my opinion—when combined with middleware. So let''s take a look at an example.\n\n### Explained by example: country restriction\n\nImagine that you are working on an application like [IMDb](https://www.imdb.com) that has a front-facing public website and an internal administration panel. One of the requirements might be that certain movies should only be shown to users if the user''s country is available in a certain whitelist, otherwise it should be as if the movie doesn''t exist at all. Long story short, you have to partition the data based on the origin country. However, this restriction should only be applied to the public website, **not** the internal administration panel. An effortless way to implement this requirement is by leveraging *not-so-global global scopes*.\n\nFirst, create your global scope like you always would:\n\n```php\nfinal readonly class CountryRestrictionScope implements Scope\n{\n    public function __construct(private Country $country) {}\n\n    public function apply(Builder $builder, Model $model): void\n    {\n        // pseudocode: do the actual country-based filtering here\n        $builder->isAvailableIn($this->country);\n    }\n}\n```\n\nNext, create an HTTP middleware whose responsibility is going to be applying the scope to the relevant models:\n\n```php\nfinal readonly class RestrictByCountry\n{\n    public const NAME = ''country.restrict'';\n\n    public function __construct(private Repository $geo) {}\n\n    public function handle(Request $request, Closure $next): mixed\n    {\n        $scope = new CountryRestrictionScope($this->geo->get());\n\n        Movie::addGlobalScope($scope);\n        Rating::addGlobalScope($scope);\n        Review::addGlobalScope($scope);\n\n        return $next($request);\n    }\n}\n```\n\n*Note: `Repository` in this example can be anything that returns the user''s country, like [laravel-geo](https://github.com/dive-be/laravel-geo).*\n\nFinally, open up your `web.php` routes file and apply the middleware to the relevant group:\n\n```php\n$router->group([\n    ''middleware'' => [''web'', RestrictByCountry::NAME],\n], static function ($router) {\n    $router->resource(''movies'', Site\MovieController::class);\n    $router->resource(''ratings'', Site\RatingController::class);\n    $router->resource(''reviews'', Site\ReviewController::class);\n	\n    // Front-facing public website routes...\n});\n\n$router->group([\n    ''middleware'' => [''web'', ''auth''],\n    ''prefix'' => ''admin'',\n], static function ($router) {\n    $router->resource(''movies'', Admin\MovieController::class);\n    $router->resource(''ratings'', Admin\RatingController::class);\n    $router->resource(''reviews'', Admin\ReviewController::class);\n	\n    // Admin routes...\n});\n```\n\nPay close attention to the fact that the middleware only gets applied to the public website routes. This has the following implications:\n\n- Whenever a user visits any of the public website routes, the content will be automatically filtered based on country. This might result in harmless 404 pages.\n- Whenever new routes need to be added due to new feature requests, the developers do not have to remember the fact that each model should be filtered based on the user''s country. This has been dealt with already and there''s no way this restriction can be bypassed unless done deliberately.\n- Whenever developers use a REPL like tinker, they won''t be caught off-guard because a hidden, nasty global scope was altering the queries. Remember, our global scopes are *not-so-global*.\n- Whenever an administrator visits the internal administration panel, they are always going to see all content regardless of their origin. This is exactly what we want.\n\nTo put it succinctly, if we embrace the global nature of global scopes while thinking about the precise placement and its area of effect, we can actually create joyful development experiences while eliminating potential frustrations in the future. It doesn''t have to be infuriating!\n\n### Bonus: combining with [tappable scopes](#tappable-scopes)\n\nThere is nothing stopping us for doing things like this:\n\n```php\nfinal readonly class FileScope implements Scope\n{\n    public function __invoke(Builder $builder): void\n    {\n        $this->apply($builder, File::make());\n    }\n\n    /** @param File $model */\n    public function apply(Builder $builder, Model $model): void\n    {\n        $builder\n            ->where($model->qualifyColumn(''model_type''), ''directory'')\n            ->where($model->qualifyColumn(''collection_name''), ''file'');\n    }\n}\n```\n\n`__invoke` is meant to make the `Scope` tappable, and `apply` is to adhere to the `Scope` contract which is a requirement for (not-so-global) global scopes.\n\n- You''d like to use the scope as a truly global scope in certain contexts? Check.\n- You''d like to apply the scope to certain queries using the tappable way? Also check.\n\n## Phantom properties\n\nIn a fairly recent project I worked on, I had to display a huge amount of markers on an interactive map like [Google Maps](https://developers.google.com/maps), [Leaflet](https://leafletjs.com) or [Mapbox](https://www.mapbox.com/developers). These interactive maps accept a list of geometry types according to the [GeoJSON spec](https://geojson.org). A `Point` type, which is exactly what I needed, must provide a `coordinates` property with a tuple as its value representing **(lat,lon)** respectively. The problem here is that `coordinates` represents a composite value, whereas the data is flattened as `addresses:id,latitude,longitude` in the database. The table was designed that way because of the chosen administration panel: [Laravel Nova](https://nova.laravel.com). It''s much easier to handle record creations in [Nova](https://nova.laravel.com) if you keep the structure as flat as possible. I could have simply dealt with this problem in an [Eloquent Resource](https://laravel.com/docs/10.x/eloquent-resources) (aka a transformer), but the curious programmer in me told me that there ought to be a better way. The inner me was definitely right: there is a better way thanks to—what I call—*Phantom properties*. \n\n### Explained by example: `Coordinates`\n\nTo solve the problem at hand, we first need to create the `ValueObject` that will represent address `Coordinates`:\n\n```php\nfinal readonly class Coordinates implements JsonSerializable\n{\n    private const LATITUDE_MIN  = -90;\n    private const LATITUDE_MAX = 90;\n    private const LONGITUDE_MIN = -180;\n    private const LONGITUDE_MAX = 180;\n\n    public float $latitude;\n\n    public float $longitude;\n\n    public function __construct(float $latitude, float $longitude)\n    {\n        Assert::greaterThanEq($latitude, self::LATITUDE_MIN);\n        Assert::lessThanEq($latitude, self::LATITUDE_MAX);\n        Assert::greaterThanEq($longitude, self::LONGITUDE_MIN);\n        Assert::lessThanEq($longitude, self::LONGITUDE_MAX);\n\n        $this->latitude  = $latitude;\n        $this->longitude = $longitude;\n    }\n\n    public function jsonSerialize(): array\n    {\n        return [$this->latitude, $this->longitude];\n    }\n\n    public function __toString(): string\n    {\n        return "({$this->latitude},{$this->longitude})";\n    }\n}\n```\n\nNext, we should define our `AsCoordinates` object cast:\n\n```php\nfinal readonly class AsCoordinates implements CastsAttributes\n{\n    public function get(\n        $model, \n        string $key,\n        $value, \n        array $attributes,\n    ): Coordinates {\n        return new Coordinates(\n            (float) $attributes[''latitude''], \n            (float) $attributes[''longitude''],\n        );\n    }\n\n    public function set(\n        $model, \n        string $key,\n        $value, \n        array $attributes,\n    ): array {\n        return $value instanceof Coordinates ? [\n            ''latitude'' => $value->latitude,\n            ''longitude'' => $value->longitude,\n        ] : throw new InvalidArgumentException(''Invalid value.'');\n    }\n}\n```\n\nFinally, we should assign it as a cast in our `Address` model:\n\n```php\nfinal class Address extends Model\n{\n    protected $casts = [\n        ''coordinates'' => AsCoordinates::class,\n    ];\n}\n```\n\nNow, we can just simply use it in our Eloquent Resource:\n\n```php\n/** @mixin \App\Models\Address */\nfinal class FeatureResource extends JsonResource\n{\n    public function toArray($request): array\n    {\n        return [\n            ''geometry'' => [\n                ''type'' => ''Point'',\n                ''coordinates'' => $this->coordinates,\n            ],\n            ''properties'' => $this->only(''name'', ''phone''),\n            ''type'' => ''Feature'',\n        ];\n    }\n}\n```\n\n- `Coordinates` is now fully responsible for the concept of `Coordinates` (representing a two-dimensional point on earth).\n- We don''t have to call `jsonSerialize()` by ourselves because of the implemented interface. It''ll be taken care of for us due to Laravel calling `json_encode` somewhere in the call stack.\n- If something were to change about `Coordinates`, it''ll be trivial to find where the concept of `Coordinates` is being used.\n\nThis is what we ended up with as expected:\n\n```json\n{\n    "geometry": {\n        "type": "Point",\n        "coordinates": [4.5, 51.5]\n    },\n    "properties": {\n        "name": "Acme Ltd.",\n        "phone": "123 456 789 0"\n    },\n    "type": "Feature"\n}\n```\n\n### Explained by another example: rendering address lines\n\nAnother handy way of using phantom properties is to help you with template rendering. Normally, if you wanted to render the address as HTML, you''d have to do something like this:\n\n```html\n<address>\n  <span>{{ $address->line_one }}</span>\n  @if($two = $address->line_two)<span>{{ $two }}</span>@endif\n  @if($three = $address->line_three)<span>{{ $three }}</span>@endif\n</address>\n```\nAs you can see, it can get out of hand really quickly. While I do recognize this is a rather contrived example, as addresses are generally rendered differently based on country, it helps with painting the picture that it can become a mess rather fast. What if we could do something like this:\n\n```html\n<address>\n  @foreach($address->lines as $line)\n  <span>{{ $line }}</span>\n  @endforeach\n</address>\n```\n\nMuch nicer, right? Our template is no longer concerned with how complex it can suddenly become due to different rules in different nations. It does what it does best: rendering. The *phantom property* responsible for this could look as follows:\n\n```php\nfinal readonly class AsLines implements CastsAttributes\n{\n    public function get(\n        $model, \n        string $key,\n        $value, \n        array $attributes,\n    ): array {\n        return array_filter([\n            $attributes[''line_one''],\n            $attributes[''line_two''],\n            $attributes[''line_three''],\n        ]);\n    }\n\n    public function set(\n        $model, \n        string $key,\n        $value, \n        array $attributes,\n    ): never {\n        throw new RuntimeException(''Set the lines explicitly.'');\n    }\n}\n```\n\nIf we had to swap `line_two` and `line_three` for Antarctica for example, we can do the adjustment in `AsLines` and won''t have to adjust the blade template at all. Thinking out-of-the-box can greatly simplify how we can render UIs and prevent us from creating overly smart ones which is generally frowned upon and considered an anti-pattern.\n\n### A note on what''s available in the docs\n\nThese properties do not directly map to a database column, and are comparable to the [Accessors & Mutators](https://laravel.com/docs/10.x/eloquent-mutators#accessors-and-mutators) combination. The documentation calls it [Value Object Casting](https://laravel.com/docs/10.x/eloquent-mutators#value-object-casting), but I think it''s heavily misleading as it''s not a requirement to cast it to a [ValueObject](https://martinfowler.com/bliki/ValueObject.html) with this approach. Reason being is that besides the examples I gave above, another use case might be the generation of product numbers that are comprised of segments. You''d want to generate and persist a value like `CA‑01‑00001` but actually save it in three distinct columns (`number_country` - `number_department` - `number_sequence`) for much easier querying:\n\n```php\nfinal readonly class AsProductNumber implements CastsAttributes\n{\n    public function get(\n        $model, \n        string $key,\n        $value, \n        array $attributes\n    ): string {\n        return implode(''-'', [\n            $attributes[''number_country''],\n            Str::padLeft($attributes[''number_department''], 2, ''0''),\n            Str::padLeft($attributes[''number_sequence''], 5, ''0''),\n        ])\n    }\n\n    public function set(\n        $model, \n        string $key,\n        $value, \n        array $attributes,\n    ): array {\n        [$country, $dept, $sequence] = explode(''-'', $value, 2);\n\n        return [\n            ''number_country'' => $country,\n            ''number_department'' => (int) $dept,\n            ''number_sequence'' => (int) $sequence,\n        ];\n    }\n}\n```\n\nNeedless to say that you should also create a unique, composite index that spans these three columns. The phantom property responsible for this would create the composed `string` value `CA‑01‑00001` and **not** a `ValueObject`, hence why it is misleading.\n\n## Fluent query objects\n\nI already mentioned custom `Builder` classes in the first section [tappable scopes](#tappable-scopes). While they''re a first good step towards more readable and maintainable queries, I think that they quickly fall apart when a lot of custom constraints need to be added to the custom `Builder` classes. They just tend to become another type of [God object](https://en.wikipedia.org/wiki/God_object). It''s also a lot of hassle to get the IDE to the point where it starts helping you with suggestions. You could also create a dedicated `Repository` for your models, but I dislike that option heavily. You see, to my eye, a `Repository` and `Eloquent` are mutually exclusive.—Before you take out the pitchforks, I *know* that it''s not strictly true. However, if you know why `ActiveRecord` exists and why a `Repository` exists, then you''ll understand where I''m coming from.—You can read more on that [here](https://muhammedsari.me/repositories-and-their-true-purpose). \n\nAnother alternative is the utilization of what is known as a `QueryObject`. It is an object that''s responsible for the composition and execution of a single query kind. While this doesn''t fully conform to the [definition of Martin Fowler in PoEAA](https://www.martinfowler.com/eaaCatalog/queryObject.html), it is close enough and I think that borrowing the notion for this particular purpose is fine. If you have a Laracasts subscription, you might have already seen the [lesson that''s available on this subject](https://laracasts.com/series/whip-monstrous-code-into-shape/episodes/17). Even though the philosophy and the way of thinking are identical, I''d like to present an alternate API that''s much, much nicer to use: *fluent query objects*.\n\n### Explained by example: notification center\n\nImagine that we have an SPA, powered by an HTTP JSON API, that has a notification bell at the top. The back-end exposes an endpoint that we can use to retrieve unread notifications of the logged in user. The `Controller` method responsible for retrieving unread notifications might look as follows:\n\n```php\npublic function index(Request $request): AnonymousResourceCollection\n{\n    $notifications = Notification::query()\n        ->whereBelongsTo($request->user())\n        ->latest()\n        ->whereNull(''read_at'')\n        ->get();\n\n    return NotificationResource::collection($notifications);\n}\n```\n\nThis was all straightforward until a new feature request came in that required us to create a dedicated page to manage all of the notifications: read, unread, type of notification etc. To make the lives of our front-end developers easier, we decided to create a dedicated endpoint per view type. One of them, which is responsible for retrieving read notifications, might look as follows\n\n```php\npublic function index(Request $request): AnonymousResourceCollection\n{\n    $notifications = Notification::with(''notifiable'')\n        ->whereBelongsTo($request->user())\n        ->latest()\n        ->whereNotNull(''read_at'')\n        ->get();\n\n    return NotificationResource::collection($notifications);\n}\n```\n\nEagle-eyed readers may already have noticed that everything in this snippet is the same as the previous one except the `whereNotNull` clause and the eager loading of the `notifiable` relation. Now we have to repeat this process for the other types as well:\n\n```php\npublic function index(Request $request): AnonymousResourceCollection\n{\n    $notifications = Notification::query()\n        ->whereBelongsTo($request->user())\n        ->latest()\n        ->where(''data->type'', ''='', $request->type)\n        ->get();\n\n    return NotificationResource::collection($notifications);\n}\n```\n\nI think you get the gist of it. This is too much repetition, and something must be done about it. Enter **fluent query objects**. \nFirst, we''re going to create the query class that will be responsible for "getting my notifications":\n\n```php\nfinal readonly class GetMyNotifications\n{\n}\n```\n\nNext, we''re going to move the base query (the conditions that''ll need to be applied at all times) to the `constructor` of our brand new, shiny object:\n\n```php\nfinal readonly class GetMyNotifications\n{\n    private Builder $builder;\n\n    private function __construct(User $user)\n    {\n        $this->builder = Notification::query()\n            ->whereBelongsTo($user)\n            ->latest();\n    }\n\n    public static function query(User $user): self\n    {\n        return new self($user);\n    }\n}\n```\n\nNow, we need to tap into the prowess of composition by utilizing the [`ForwardsCalls`](https://github.com/laravel/framework/blob/10.x/src/Illuminate/Support/Traits/ForwardsCalls.php) trait:\n\n```php\n/** @mixin \Illuminate\Database\Eloquent\Builder */\nfinal readonly class GetMyNotifications\n{\n    use ForwardsCalls;\n\n    // omitted for brevity\n\n    public function __call(string $name, array $arguments): mixed\n    {\n        return $this->forwardDecoratedCallTo(\n            $this->builder, \n            $name, \n            $arguments,\n        );\n    }\n}\n```\n\nObservations:\n\n- `ForwardsCalls` allows us to treat the class as if it''s a part of the "base class" `\Illuminate\Database\Eloquent\Builder` even though there is no inheritance in place. I love composition.\n- The `@mixin` annotation will help the IDE to provide us with useful autocompletion suggestions.\n- You could also choose to add `Conditionable` to have an even more fluent API, but it''s not really necessary here due to our design choice (a distinct endpoint per view type).\n\nThe only things remaining now are the custom query constraints, so let''s add them:\n\n```php\n/** @mixin \Illuminate\Database\Eloquent\Builder */\nfinal readonly class GetMyNotifications\n{\n    // omitted for brevity\n	\n    public function ofType(NotificationType ...$types): self\n    {\n        return $this->whereIn(''data->type'', $types);\n    }\n\n    public function read(): self\n    {\n        return $this->whereNotNull(''read_at'');\n    }\n\n    public function unread(): self\n    {\n        return $this->whereNull(''read_at'');\n    }\n	\n    // omitted for brevity\n}\n```\n\nAwesome. We now have everything that''s needed to properly implement the feature "get my notifications" aka the notification center. So with everything stitched together: \n\n```php\n/** @mixin \Illuminate\Database\Eloquent\Builder */\nfinal readonly class GetMyNotifications\n{\n    use ForwardsCalls;\n\n    private Builder $builder;\n\n    private function __construct(User $user)\n    {\n        $this->builder = Notification::query()\n            ->whereBelongsTo($user)\n            ->latest();\n    }\n\n    public static function query(User $user): self\n    {\n        return new self($user);\n    }\n\n    public function ofType(NotificationType ...$types): self\n    {\n        return $this->whereIn(''data->type'', $types);\n    }\n\n    public function read(): self\n    {\n        return $this->whereNotNull(''read_at'');\n    }\n\n    public function unread(): self\n    {\n        return $this->whereNull(''read_at'');\n    }\n\n    public function __call(string $name, array $arguments): mixed\n    {\n        return $this->forwardDecoratedCallTo(\n            $this->builder, \n            $name, \n            $arguments,\n        );\n    }\n}\n```\n\nLet''s refactor one of the previous `Controller`s and see how it looks:\n\n```php\npublic function index(Request $request): AnonymousResourceCollection\n{\n    $notifications = GetMyNotifications::query($request->user())\n        ->read()\n        ->with(''notifiable'')\n        ->get();\n\n    return NotificationResource::collection($notifications);\n}\n```\n\nI don''t know about you, but this piece of elegant code is just beautiful to look at. You can keep using all of the regular [`Illuminate\Database\Eloquent\Builder`](https://laravel.com/api/10.x/Illuminate/Database/Eloquent/Builder.html) methods while also having the ability to call enhanced, specific methods dedicated to this distinct query alone. Takeaways:\n\n- Key concepts are encapsulated behind meaningful interfaces.\n- Adheres to [SRP](https://en.wikipedia.org/wiki/Single-responsibility_principle)\n- Groks the framework and its tools instead of fighting against it like using a `Repository`\n- Easily reusable in multiple places\n- Easily testable\n\n### Bonus: combining with [tappable scopes](#tappable-scopes)\n\nThere is nothing stopping us from doing things like this:\n\n```php\nfinal readonly class GetMyNotifications\n{\n    // omitted for brevity\n	\n    public function ofType(NotificationType ...$types): self\n    {\n        return $this->tap(new InType(...$types));\n    }\n\n    public function read(): self\n    {\n        return $this->tap(new Read());\n    }\n\n    public function unread(): self\n    {\n        return $this->tap(new Unread());\n    }\n	\n    // omitted for brevity\n}\n```\n\nPerhaps we needed to create these scopes for a [not-so-global](#not-so-global-global-scopes) use case. It makes a lot of sense to reuse them here in order to maintain consistency. Your imagination is the only limiting factor here.\n\n### Note on using a `Pipeline`\n\nThere are [plenty of tutorials on YouTube](https://www.youtube.com/watch?v=9E5IevdHPwA) that show how we could be using a `Pipeline` to logically split a chain of operations, or do some complex filtering. Some readers might think that it''s a waste of time to deal with your own `QueryObject`. The thing is though, I don''t believe that a `Pipeline` and a `QueryObject` are mutually exclusive. They can be complementary to eachother and help one another to complete the task more efficiently. Instead of type-hinting `Builder` in the pipes, we can type-hint our custom `QueryObject`s. Essentially building our own [laravel-query-builder](https://github.com/spatie/laravel-query-builder), but with a more specific API.\n\nThe `Pipeline` could look as follows:\n\n```php\n$orders = Pipeline::send(\n    GetMyOrders::query($request->user())\n)->through([\n    Filter\Cancelled::class,\n    Filter\Delayed::class,\n    Filter\Shipped::class,\n])->thenReturn()->get();\n```\n\nA `Pipe` could look as follows:\n\n```php\nfinal readonly class Cancelled\n{\n    public function __construct(private Request $request) {}\n\n    public function handle(GetMyOrders $query, Closure $next): mixed\n    {\n        if ($this->request->boolean(''cancelled'')) {\n            $query->cancelled();\n        }\n\n        return $next($query);\n    }\n}\n```\n\nThere''s nothing wrong with amalgamating different concepts to reach your end goal. Just make sure it makes sense for your current context and that you''re not introducing accidental complexity.\n\n## Sharing eager loads\n\nThis is a concise, but indispensable one (for me, at least). At some point you probably found yourself wondering how you could be sharing eager loads, especially those that do some additional refining, but nevertheless still ended up just copy-pasting the relevant code. While copy-paste is a perfectly valid option to choose, there are in fact better ways to solve this issue. It can quickly become cumbersome to repeat these kinds of eager loads because of the application of additional query constraints. This could be the case when using Spatie''s phantasmagorical package [laravel-medialibrary](https://github.com/spatie/laravel-medialibrary), for example.\n\nImagine that you have 10 different models. Each model defines multiple, distinct `MediaCollection`s and each model also defines a `thumbnail` for display purposes on the storefront. For various reasons, `Controller` code etc. cannot be shared ([you shouldn''t anyway](https://muhammedsari.me/controllers-and-their-true-purpose)). The package works with one big `media` relation that loads in all attached `Media` objects and uses `Collection` magic in the background in order to partition them. Eager loading the entire `media` relation can quickly become a problem on an index page that lists a model with tons of `MediaCollection`s. After all, the only thing we need on an index page is the model''s `thumbnail`. In order to solve this problem, we can apply a query constraint like so:\n\n```php\npublic function index(): View\n{\n    $products = Product::with([\n        ''categories'',\n        ''media'' => static function (MorphMany $query) {\n            $query->where(''collection_name'', ''thumbnail'')\n        },\n        ''variant.media'' => static function (MorphMany $query) {\n            $query->where(''collection_name'', ''thumbnail'')\n        },\n    ])->tap(new Available())->get();\n\n    return $this->view->make(''products.index'', compact(''products''));\n}\n```\n\nWhile this does solve the problem of overfetching, it is not pretty to look at. Now repeat this 9 more times. Yuck! Actually it is very, very straightforward to properly tackle this problem. First, think about what you want to eager load. Got it? `LoadThumbnail`. Then, create a class that represents this constraint:\n\n```php\nfinal readonly class LoadThumbnail implements Arrayable\n{\n    public function __invoke(MorphMany $query): void\n    {\n        $query->where(''collection_name'', ''thumbnail'');\n    }\n\n    public function toArray(): array\n    {\n        return [''media'' => $this];\n    }\n}\n```\n\nNow simply use it:\n\n```php\npublic function index(): View\n{\n    $products = Product::with([\n        ''categories'',\n        ''media'' => new LoadThumbnail(),\n        ''variant.media'' => new LoadThumbnail(),\n    ])->tap(new Available())->get();\n\n    return $this->view->make(''products.index'', compact(''products''));\n}\n```\n\nAmazing, right? You may have also noticed the `toArray` at the bottom. That would come in handy if you''d like to define eager loads 1 relation at a time with consecutive `with((new LoadThumbnail)->toArray())` calls. This technique is so simple to execute it''s just unfair almost. Please don''t overfetch and instead make sure minimal data is returned over the wire from the database. Laziness is no excuse!\n\n## Invokable accessors\n\nWe''ve already talked about techniques like [Phantom properties](#phantom-properties). If you haven''t read that section yet, please read it first and come back to this one. Anyway, the biggest flaw with [Phantom properties](#phantom-properties) is that it requires us to define a `set` (inbound) cast even if we won''t be using it, like the `$address->lines` example; and also that it has no mechanism that automatically memoizes the computed results. It''s a bummer that there''s no `CastsOutboundAttributes`, but that''s where invokeable accessors shine. The main benefits are:\n\n- Memoization\n- No model clutter\n- Testable units\n- Composable, like any other object\n\nAn example definition (`Attribute::get` is real, by the way):\n\n```php\nfinal class File extends Model\n{\n    protected function stream(): Attribute\n    {\n        return Attribute::get(new StreamableUrl($this));\n    }\n}\n```\n\nThat''s all it takes to define an invokeable accessor. Take note of the constructor argument, because that''s a repeating pattern with invokeable accessors. It''s necessary to gain access to the model that''s being used, otherwise we won''t be able to gather contextual information necessary to carry out our tasks. In this example, `StreamableUrl` is responsible for—you guessed it—generating streamable URLs. We could have inlined the logic and used the [classic `Closure` way](https://laravel.com/docs/10.x/eloquent-mutators#defining-an-accessor), but that would start filling up our model rather quickly. The actual model this snippet is coming from, has fourteen other accessors (!). A sneak peek from this particular invokeable accessor:\n\n```php\nfinal readonly class StreamableUrl\n{\n    private const S3_PROTOCOL = ''s3://'';\n\n    public function __construct(private File $file) {}\n\n    public function __invoke(): string\n    {\n        $basePath = UuidPathGenerator::getInstance()\n            ->getPath($this->file);\n\n        if ($this->file->supports(''s3'')) {\n            return self::S3_PROTOCOL \n                . $this->file->bucket \n                . DIRECTORY_SEPARATOR \n                . $basePath \n                . $this->file->basename;\n        }\n\n        return Storage::disk($this->file->disk)\n            ->url($basePath . rawurlencode($this->file->basename));\n    }\n}\n```\n\nThe exact details are not that important, but the takeaway is that it properly encapsulates the logic for generating **optimized** streamable URLs. Returning direct `s3://` paths is much more efficient for streaming files from [S3](https://aws.amazon.com/s3/).\n\nThe main point is, imagine if we had defined this code inside a traditional `Closure` within the accessor on the model itself, and also done something similar for the other thirteen accessors. Our model would have very quickly become overstuffed. Using invokable accessors also allows us to extract out such code and keep our models clean and tidy.\n\n## Multiple read models for the same table\n\nThis is one of those rare moments where I actually appreciated the limitations of [Laravel Nova](nova.laravel.com), which is normally notoriously difficult to customize compared to other administration panel solutions. It allowed me to discover a novel use case for read-only models. \n\nRecently, a feature request came in that required us to create a fully-fledged file explorer in order to share files with third parties and customers. Rolling out our own file management solution was out of the question because 1. it is a solved problem and 2. it is a complex and edgecase-ridden problem. We decided to go with [laravel-medialibrary](https://github.com/spatie/laravel-medialibrary) (as any other sane person would, thanks Spatie!), but there was a huge hurdle to overcome. We had to create a UX-friendly interface in Nova under the `Directory` resource, which would be housing the `File`s that belonged to that particular `Directory` **and** it had to be sortable. While the default `Media` model did its job well, it was incompatible with Nova''s most popular sorting library (also from Spatie). We had to come up with an original solution. That''s when it suddenly struck me to create a read-only model for the `media` table and put the theory to the test:\n\n```php\nfinal class File extends Model implements Sortable\n{\n    use SortableTrait;\n\n    public array $sortable = [\n        ''order_column_name'' => ''order_column'';\n    ];\n\n    protected $table = ''media'';\n\n    public function buildSortQuery(): Builder\n    {\n        return $this->newQuery()->where($this->only(''model_id''));\n    }\n}\n```\n\nWhile this was already looking promising, there was another hurdle that had to be overcome. This model could be used to query **anything** in the `media` table which could have resulted in unexpected data losses. This was not acceptable of course, because this model specifically represents a `File` which is actually a `Media` object that fulfills two criteria:\n\n- It must belong to the model `Directory`\n- The `collection_name` must be `file`\n\nI decided to create a **true** global scope and register it in a `ServiceProvider` to enforce these rules at all times (another rare moment where a truly global scope actually makes sense):\n\n```php\nfinal class FileScope implements Scope\n{\n    /** @param File $model */\n    public function apply(Builder $builder, Model $model): void\n    {\n        $builder\n            ->where($model->qualifyColumn(''model_type''), ''directory'')\n            ->where($model->qualifyColumn(''collection_name''), ''file'');\n    }\n}\n```\n\nModels that did not fit these criteria were no longer being returned and instead started throwing `ModelNotFoundException`s. This was exactly what we wanted. Perfect, but we couldn''t declare victory just yet. The Nova interface required a bunch of information which were simply not possible to extract from the default `Media` model. But then it struck me again: since this was our custom model, I could do whatever I wanted! I could even declare it as a relation now in the `Directory` model:\n\n```php\npublic function files(): HasMany\n{\n    return $this->hasMany(File::class, ''model_id'')->ordered();\n}\n```\n\nDid you notice something "weird"? No? Take a look at the relationship type. If you know how MediaLibrary works, you''d know that the `media` table actually makes use of a `MorphMany` relationship. But since we defined a global `FileScope` that always refines the queries on `model_type`, we can simply use the `HasMany` relation type by itself and **everything just works**. This is when my mind was blown. Calling `$directory->files` would now return a `Collection` of `File` objects and not `Media` objects. Long story short, `File` now possessed everything that was needed to serve a `FileSharing` context. We didn''t need to alter any configuration or something else—nothing. Just some cleverness and novel approaches. The end result was pure excellence.\n\ne.g. I could also add a bunch of [(invokeable) accessors](#invokeable-accessors) in order to fulfill the UI needs:\n\n```php\n// other accessors ommitted, there''s simply too many\n\nprotected function realpath(): Attribute\n{\n    return Attribute::get(new Realpath($this));\n}\n\nprotected function stream(): Attribute\n{\n    return Attribute::get(new StreamableUrl($this));\n}\n\nprotected function extension(): Attribute\n{\n    return Attribute::get(fn () => $this->type->extension());\n}\n\nprotected function type(): Attribute\n{\n    return Attribute::get(fn () => FileType::from($this->mime));\n}\n```\n\n### Takeways\n\n- You should use a read-only model when things get complex on the UI side.\n- Global scopes are not always bad.\n- These models allow for fine-tuning according to the use cases that they need to support.\n- This approach can also be used if a package does not allow you to override the "base model" that it uses. Simply create your own model that references the package''s table and start solving problems.\n\n## `WithoutRelations` for queue performance\n\nLast but not least, the topic I''d like to talk about is the mysterious `WithoutRelations` attribute or the `withoutRelations` method. Avid and eagle-eyed source divers of Laravel packages may have already noticed some usage while browsing through the source code. In fact, it is indeed used in a [Livewire component by Laravel Jetstream](https://github.com/laravel/jetstream/blame/4.x/src/Http/Livewire/UpdateProfileInformationForm.php#L46). Though the reason why it''s being used here is to prevent too much information leaking to the client-side, which is—even though completely valid—not the use case I''d like to talk about.\n\nAs you may already know, you should be using the `SerializesModels` trait if you''d like to enqueue a `Job` that houses Eloquent models. (Its purpose is briefly described [in the documentation](https://laravel.com/docs/10.x/queues#class-structure), so I''m not going to repeat that.) But there is a catch that a lot of developers are not aware of: `SerializesModels` also remembers which relationships were loaded at serialization-time and uses that information to reload *all* relationships when the models are deserialized. An example payload:\n\n```json\n{\n    "user": {\n        "class": "App\\Models\\User",\n        "id": 10269,\n        "relations": [''company'', ''orders'', ''likes''],\n        "connection": "mysql",\n        "collectionClass": null\n    }\n}\n```\n\nAs you can see, the `relations` property contains three relationships. These will be eagerly loaded upon the deserialization of this `Job`. A relationship like `likes` and `orders` can potentially pull in hundreds or even thousands of records, hurting the `Job`s performance tremendously. Even worse, the `Job` from which I grabbed this snapshot didn''t even need any of these relations to carry out its main task. \n\n### Method option\n\nAn easy way to fix this problem is by—you guessed it—using the `withoutRelations` method before passing along your Eloquent models to the `Job`s constructor. An example:\n\n```php\nfinal class AccessIdentitySubscriber\n{\n    public function subscribe(Dispatcher $events): void\n    {\n        $events->listen(\n            Registered::class, \n            $this->whenRegistered(...),\n        );\n    }\n\n    private function whenRegistered(Registered $event): void\n    {\n        CreateProspect::dispatch($event->user->withoutRelations());\n    }\n}\n```\n\nThis event subscriber is responsible for creating a new prospect in a disparate CRM system whenever a new user is registered in our application. Before dispatching `CreateProspect`, `withoutRelations` is called in order to make sure no useless relationships are serialized beyond this point, ensuring optimal performance. If we now inspect the serialized payload, we can see that the array has been emptied:\n\n```json\n{\n    "user": {\n        "class": "App\\Models\\User",\n        "id": 10269,\n        "relations": [],\n        "connection": "mysql",\n        "collectionClass": null\n    }\n}\n```\n\nPerfect.\n\n### Attribute option\n\nWhile preparing this blog post, I realized that a fellow Laravel developer [contributed a brand new `#[WithoutRelations]` attribute](https://github.com/laravel/framework/pull/48068) that automatically takes care of stripping away all model relations upon `Job` serialization:\n\n```php\n#[WithoutRelations]\nfinal class CreateProspect implements ShouldQueue\n{\n    use Dispatchable;\n    use InteractsWithQueue;\n    use SerializesModels;\n\n    public function __construct(private User $user) {}\n\n    public function handle(Gateway $crm): void\n    {\n        // omitted for brevity\n    }\n}\n```\n\nThis will definitely be my new default way of defining `Job`s. I also don''t know about you, but I have had **zero** use cases where have I said to myself "Darn it, I should have left the relations alone". This behavior introduces more hidden bugs than anything (in my experience). Most of the time, [lazy loading](https://laravel.com/docs/10.x/eloquent-relationships#relationship-methods-vs-dynamic-properties) does the job just fine. Remember, there are no bad tools. There are only bad tools **within a particular context**. That''s why I''m not a huge fan of the newish [`Model::preventLazyLoading`](https://laravel.com/docs/10.x/eloquent-relationships#preventing-lazy-loading) feature. Sorry, [namesake](https://twitter.com/taylorotwell/status/1395087054254526474).\n\n## Wrap‑up\n\nAt this point my fingers are numb, but I think it was worth it. Curiosity makes you a better programmer, so get out of the tutorial hell and start experimenting. Trust me, the worst thing that can happen is you learning. And please... don''t forget to read up on the [trade‑offs of Active Record](https://shawnmc.cool/2023-02-13_active-record-how-we-got-persistence-perfectly-wrong). The worst thing that can happen is—again—you learning.\n\n[Join the discussion on X (formerly Twitter)!](https://twitter.com/mabdullahsari/status/1702289877520261180) I''d love to know what you thought about this blog post.\n\nThanks for reading!','\n',char(10)),'I''ve been working with Eloquent for over half a decade now, and it''s time to share my bag of tricks. Buckle up, it''ll be a good ride!','published','2023-09-14 11:38:34','2023-08-29 13:21:27','2024-01-29 13:11:54');
INSERT INTO blogging_posts VALUES(4,1,'unorthodox-eloquent-2','Unorthodox Eloquent II',replace('*This is part 2 of the miniseries "Unorthodox Eloquent". If you haven''t read the original post yet, you can do so [here](https://muhammedsari.me/unorthodox-eloquent).*\n\n[Last post](https://muhammedsari.me/unorthodox-eloquent), we explored a wide variety of "unorthodox" options that could be used in conjunction with our Eloquent models. That article, however, was just the tip of the iceberg. In this blog post, I''d like to go over a few other tips and tricks that might be a bit more esoteric—but nevertheless still handy—than the topics presented in the first post. For example, have you ever considered using model factories outside of your seeders or tests? No? Well, then I''m pretty sure you''ll learn a thing or two again so make sure you stick around until the end!\n\n*Like every tool in existence, Eloquent comes with its own set of trade-offs. As responsible developers, we should always be aware of the things we are trading off against. If you''d like to learn more about [ActiveRecord](https://www.martinfowler.com/eaaCatalog/activeRecord.html) and its design philosophy, I highly recommend this [article by Shawn McCool](https://shawnmc.cool/2023-02-13_active-record-how-we-got-persistence-perfectly-wrong).*\n\n## Quick navigation\n\n* [Model factories in app code](#model-factories-in-app-code)\n* ["Native" belongsToThrough relation](#quotnativequot-belongstothrough-relation)\n* [Fully grokking Eloquent](#fully-grokking-eloquent)\n* [Tappable scopes in-depth](#tappable-scopes-in-depth)\n\n## Model factories in app code\n\nIn order to fully appreciate this section, I think we should first establish a precise common understanding of what a [`Factory`](https://refactoring.guru/design-patterns/factory-comparison) is. Put simply, it is something that is responsible for the generation of another thing. However, I''d like go one step further and define it as something that is responsible for the [genesis](https://dictionary.cambridge.org/dictionary/english/genesis) of another entity. Typically, all models / entities have a specific lifecycle: they start existing for some particular reason, go through a certain process and eventually cease to exist or "die". A `Factory` is especially useful for dealing with the first part of an entity''s lifecycle.\n\n[Eloquent Factories](https://laravel.com/docs/10.x/eloquent-factories#defining-model-factories) have existed for quite a while now. From the documentation, verbatim:\n\n> When testing your application or seeding your database, you may need to insert a few records into your database.\n\nIt is depicted as if testing and seeding are the only use cases where [Eloquent Factories](https://laravel.com/docs/10.x/eloquent-factories#defining-model-factories) make sense, but nothing could be further from the truth. They can be used in your application code as well without needing to worry about accidentally breaking something or giving someone too many rights. But we would be mixing up test / seed code with application code, right? Wrong!\n\n### Preparation\n\nFirst and foremost, we should decide on a location to place our test-only factories for use in integration or feature tests. I prefer to leave `database/factories` alone for application code since it''s also auto-discovered by the framework. `tests/Factories` would be a good candidate to place our testing specific factories. So go ahead and move the test-only factories to their new location. After the files have been moved, we now have to tell the factory discoverer to check our new location *while running tests*. To achieve this, we should define a new `FactoryResolver` class in the root of our tests folder:\n\n```php\nfinal readonly class FactoryResolver\n{\n    public function __invoke(string $fqcn): string\n    {\n        $model = class_basename($fqcn);\n\n        return "Tests\\Factories\\{$model}Factory";\n    }\n}\n```\n\nNext, we should define a `TestingServiceProvider` in the root of our tests folder in which the `FactoryResolver` is registered:\n\n```php\nfinal class TestingServiceProvider extends ServiceProvider\n{\n    public function boot(): void\n    {\n        Factory::guessFactoryNamesUsing(new FactoryResolver());\n    }\n}\n```\n\nWe can now register this custom `TestingServiceProvider` whenever the test application is created: \n\n```php\ntrait CreatesApplication\n{\n    public function createApplication(): Application\n    {\n        $app = require __DIR__.''/../bootstrap/app.php'';\n\n        $app->make(Kernel::class)->bootstrap();\n        $app->register(TestingServiceProvider::class); // 👈\n\n        return $app;\n    }\n}\n```\n\nYou may have noticed that we don''t add this to the `app.providers` configuration array, and why should we? This `TestingServiceProvider` is of use only during a testing context. Registering it with every real application request makes zero sense and does nothing but waste precious CPU cycles. Once everything is in place, we can go ahead and start using factories in application code on the one hand, and factories meant for testing on the other.\n\n### Explained by example: user signup\n\nLet''s assume that we have the following route for handling user signups:\n\n```php\nRoute::post(''users'', [UserController::class, ''store'']);\n```\n\nIt should be able to register users with various roles: `premium`, `vip`, `trial` etc. After the user has signed up, depending on their role, a `WelcomeEmail` should be sent to their email address. One way to do this is by adding all necessary logic to the corresponding `Controller` method. However, we already know that [that''s not a very good idea](https://muhammedsari.me/controllers-and-their-true-purpose). We can deal with this problem in a clean and *unorthodox* manner!\n\nFirst, let''s create a `UserFactory` (in `database/factories` using `php artisan make:factory`) that''s going to be responsible for generating `User` objects along with various factory methods to put them in a consistent state:\n\n```php\nfinal class UserFactory extends Factory\n{\n    protected $model = User::class;\n\n    public function definition(): array\n    {\n        return [];\n    }\n\n    public function isPremium(): self\n    {\n        return $this->state([\n            ''type'' => ''premium'',\n        ]);\n    }\n\n    public function isTrial(): self\n    {\n        return $this->state([\n            ''trial_expires_at'' => Date::now()->addWeeks(2),\n            ''type'' => ''trial'',\n        ]);\n    }\n\n    public function isVip(): self\n    {\n        return $this->state([\n            ''type'' => ''vip'',\n        ]);\n    }\n}\n```\n\nYou might have noticed that the `definition` method is rather empty. This is completely on purpose, because the goal of this method is to provide default values for database fields that would not have been set during the execution of a feature test. However, our goal is to use this class in our application code and *not* in test code so we should leave it blank. The absence of any field will denote a bug in our code and we should fix it asap. \n\nAfter having done that, we should head over to our `User` model and define a `newFactory` method that is going to return a new instance of the very factory we have just defined. This will be crucial for our tests later on:\n\n```php\nuse Database\Factories\UserFactory;\n\nfinal class User extends Authenticatable\n{\n    use HasFactory;\n\n    // omitted for brevity\n\n    protected static function newFactory(): UserFactory\n    {\n        return UserFactory::new();\n    }\n}\n```\n\nWe can now go ahead and implement the necessary `Controller` logic to fulfill the business requirements:\n\n```php\nfinal readonly class UserController\n{\n    public function store(SignUpUser $request): UserResource\n    {\n        $user = User::factory()\n            ->when($request->wantsTrial(), static fn (UserFactory $usr) => $usr->isTrial())\n            ->when($request->wantsPremium(), static fn (UserFactory $usr) => $usr->isPremium())\n            ->when($request->wantsVip(), static fn (UserFactory $usr) => $usr->isVip())\n            ->create($request->validated());\n\n        return UserResource::make($user);\n    }\n}\n```\n\nAs you can see, the "missing" `definition` attributes are provided by Laravel''s `FormRequest` validation method. Depending on the user''s selection in the front-end, we can invoke the various factory methods in order to create a valid `User` object with a valid state depending on the chosen role. Everything is fine and dandy, but we are still missing a key requirement: delivering the "welcome" mails. At this point, we could start looking into events and listeners, creating dedicated actions, process pipelines... Though just because we can, doesn''t mean we should. Instead, [let''s grok the full power of Eloquent factories](https://laravel.com/docs/10.x/eloquent-factories#factory-callbacks):\n\n```php\npublic function isTrial(): self\n{\n    return $this->state(...)->afterCreating(function (User $user) {\n        Mail::send(new WelcomeTrialUserMail($user));\n    });\n}\n```\n\n*Amàzing*, right? Pricesely knowing how your tools work unlocks an incessant amount of power right there at your disposal. Rinse and repeat three times and we are done implementing the biz requirements. \n\n### Automated testing\n\nBut what about testing? Testing is equally important as the production code itself because it validates our assumptions and ensures that the code meets the business requirements. Good news: nothing changes with the way you have been writing feature tests except one little thing.\n\nInstead of doing this during your test case preparations:\n\n```php\nUser::factory()->create();\n```\n\nYou now have to do this:\n\n```php\nuse Testing\Factories\UserFactory;\n\nUserFactory::new()->create();\n```\n\nThat''s because the former is always going to resolve the application factory while the latter will be using the factory specifically created for our test scenarios. We can go ahead and write a simple test that ensures our code works as intended:\n\n```php\nfinal class UsersTest extends TestCase\n{\n    #[Test]\n    public function premium_users_can_sign_up(): void\n    {\n        $this->post(''users'', [\n            ''email'' => ''muhammed+evilalias@GMAIL.CoM'',\n            ''name'' => ''mUhAmMeD'',\n            ''type'' => ''premium'',\n        ]);\n\n        $this->assertDatabaseHas(User::class, [\n            ''email'' => ''muhammed@gmail.com'',\n            ''name'' => ''Muhammed'',\n            ''type'' => ''premium'',\n        ]);\n        \n        Mail::assertQueued(WelcomePremiumUserMail::class);\n    }\n}\n```\n\n"But where is the `UserFactory`?", you might rightfully ask. Well, it doesn''t really make sense to use a test factory here because we are testing some behavior whose purpose is to create a `User` object for us. If you want you can obviously add more tests *if* it''ll increase your confidence levels. Please don''t add tests for the sake of testing. Make sure that you are actually netting positive value. \n\nAn example test case of another use case might look as follows:\n\n```php\nuse Tests\Factories\UserFactory;\n\n#[Test]\npublic function only_premium_users_receive_access_to_discounts(): void\n{\n    $this\n        ->actingAs(UserFactory::new()->create())\n        ->get(''discounts'')\n        ->assertForbidden();\n\n    $this\n        ->actingAs(UserFactory::new()->isPremium()->create())\n        ->get(''discounts'')\n        ->assertOk()\n        ->assertSee(''Halloween discounts!'');\n}\n```\n\nThis is where the `FactoryResolver` we defined earlier comes into play. It''ll be used by the framework to automatically resolve relational factory instances when creating other relations inside of our test factories. I **strongly discourage** the use of the factories'' relational capabilities outside of *test* factories because it''ll only be a matter of time before someone calls in and says "Wait, how the hell did he get administrator access?!". Define everything explicitly inside your application code factories. Relying on framework magic inside your test factories is totally fine.\n\n## "Native" belongsToThrough relation\n\nI don''t know about you, but time and time again I have wished that Laravel had a native `belongsToThrough` relationship because it''s so darn useful in certain scenarios. Which native relations does Laravel have that can be used [out-of-the-box](https://laravel.com/docs/10.x/eloquent-relationships) (OOB)? One definitely catches my attention: [`HasOneThrough`](https://laravel.com/docs/10.x/eloquent-relationships#has-one-through). If we think about, it''s almost what we want but the inverse. Unfortunately, it is not exactly what we want so we must fall back to using [third-party](https://github.com/staudenmeir/belongs-to-through) packages... 😔\n\nHold on a second. Why are we giving up so fast? Why don''t we go ahead and take look behind the curtains to see how this almost-the-relation-we-want-but-unfortunately-not-exactly-the-relation-that-we-want works? Why is our mentality defaulted to using third-party packages as soon as we are faced with a slightly more difficult challenge? We can *definitely* do better!\n\n### Exploration\n\n```php\npublic function hasOneThrough(\n    $related, \n    $through, \n    $firstKey = null, \n    $secondKey = null, \n    $localKey = null, \n    $secondLocalKey = null\n) {}\n```\n\nThis is the method definition of the `HasOneThrough` relationship. We can see that it allows us to customize everything with regards to the query that needs to be executed in order to fulfill the relation''s needs. If we follow [Laravel''s example of `mechanics-cars-owners`](https://laravel.com/docs/10.x/eloquent-relationships#has-one-through) and execute the relationship, the following SQL (or something very close, depending on your driver) will be generated:\n\n```php\npublic function carOwner(): HasOneThrough\n{\n    return $this->hasOneThrough(Owner::class, Car::class);\n}\n\nMechanic::find(504)->carOwner;\n```\n\n```sql\nSELECT\n	*\nFROM\n	`owners`\n	INNER JOIN `cars` ON `cars`.`id` = `owners`.`car_id`\nWHERE\n	`cars`.`mechanic_id` = 504\n```\n\nHave you noticed something? No? This is the query pattern that all `belongsToThrough` packages use! The only thing that they''re doing, is inverting the foreign and local keys and calling it a day! Didn''t we assert, just now, that the `hasOneThrough` relation allows us to customize literally everything related to the query? Let''s try it!\n\n### Solution\n\nThis is what we currently have in our `Mechanic` model:\n\n```php\npublic function carOwner(): HasOneThrough\n{\n    return $this->hasOneThrough(Owner::class, Car::class);\n}\n```\n\nLet''s go to the `Owner` model and define a relationship for our `Mechanic` model:\n\n```php\npublic function carMechanic(): HasOneThrough\n{\n    return $this->hasOneThrough(Mechanic::class, Car::class);\n}\n```\n\nEven if we tried to execute this, the SQL would crash because the query would be nonsensical. Let''s invert all keys manually and see what''s going to happen:\n\n```php\npublic function carMechanic(): HasOneThrough\n{\n    return $this->hasOneThrough(\n        Mechanic::class, \n        Car::class, \n        ''id'', \n        ''id'', \n        ''car_id'', \n        ''mechanic_id'',\n    );\n}\n\nOwner::find(2156)->carMechanic;\n```\n\nAwesome! If we inspect the generated SQL, we can see that the keys got inverted according to our definition:\n\n```sql\nSELECT\n	*\nFROM\n	`mechanics`\n	INNER JOIN `cars` ON `cars`.`mechanic_id` = `mechanics`.`id`\nWHERE\n	`cars`.`id` = 2156\n```\n\nWe can also make a tiny improvement to the relationship definition so that future self and other fellow developers can quickly understand what''s going on:\n\n```php\nuse Illuminate\Database\Eloquent\Relations\HasOneThrough as BelongsToThrough;\n\npublic function carMechanic(): BelongsToThrough\n{\n    return $this->hasOneThrough(...);\n}\n```\n\n### Some words of wisdom\n\nNext time, instead of brushing aside existing tools, try and see if you can make it work according to your needs when you make slight modifications to the default behavior. You''ll be surprised with how much you can get away with! Remember, pulling in additional dependencies also brings along maintenance burdens so you should think about it at least four times before deciding on actually pulling in a particular dependency.\n\n## Fully grokking Eloquent\n\n> I have to admit that this is going to be an extremely subjective section, but please hear me out until the end before pulling out the pitchforks and torches. Thank you. 🙏\n\nEloquent ORM comes with various tools OOB: event dispatch, transaction managing, observers, global scopes, automatic timestamp management etc. While this approach has its benefits, unequivocally it also has its drawbacks. Eloquent adheres to the *SRE* principle: *Single-handedly Responsible for Everything*. That being said, how many times have we actually taken a gander at the internal workings of this razor-sharp tool?\n\n### HasEvents\n\nFor example, did you know that all Eloquent models have direct access to the event `Dispatcher`? So, why do we do this:\n\n```php\npublic function accept(): void\n{\n    // omitted for brevity\n\n    event(new ApplicationWasAccepted($this));\n}\n```\n\nInstead of this:\n\n```php\npublic function accept(): void\n{\n    // omitted for brevity\n\n    static::$dispatcher->dispatch(new ApplicationWasAccepted($this));\n}\n```\n\n### HasTimestamps\n\nWhy this:\n\n```php\npublic function accept(): void\n{\n    $this->fill([\n        ''accepted_at'' => now(),\n    ]);\n}\n```\n\nInstead of this:\n\n```php\npublic function accept(): void\n{\n    $this->fill([\n        ''accepted_at'' => $this->freshTimestamp(),\n    ]);\n}\n```\n\nDid you know that this returns `Illuminate\Support\Carbon` instead of `Carbon\Carbon` which is the "wrong" type-hint you''ve been using all along?\n\n### Model\n\nDue to the design philosopy of ActiveRecord, all models must have access to the underlying database connection. So why do we do this:\n\n```php\npublic static function directory(User $downloader, Directory $directory): self\n{\n    // omitted for brevity\n\n    DB::transaction(static fn () => $model->save() && $model->directories()->attach($directory));\n\n    return $model;\n}\n```\n\nInstead of this:\n\n```php\npublic static function directory(User $downloader, Directory $directory): self\n{\n    // omitted for brevity\n\n    $model\n        ->getConnection()\n        ->transaction(static fn () => $model->save() && $model->directories()->attach($directory));\n\n    return $model;\n}\n```\n\n### My point\n\n[But why?](https://media.tenor.com/KjJTBQ9lftsAAAAC/why-huh.gif)\n\nI''m just trying to provoke our thoughts here and question what we have been doing all along. My presented alternatives are as much "grokking the framework" as using the other options. So why don''t we look at the tools under use next?\n\nThe latter options signal to me a seasoned developer that knows how their tools work behind the scenes. Why do we go through the entire IoC container service resolution cycle to retrieve an object that was always there to begin with? Convenience? I''d argue that neither option is more convenient than the other, because proper IDEs will always autocomplete the "longer" options...\n\n## Tappable scopes in-depth\n\nThis is going to be the shortest section of them all, because I am not going to be the one explaining it further. I''d like to give a shout-out to [Marco Deleu](https://twitter.com/deleugyn), who has already done an excellent job at going into greater depths on [Tappable scopes](https://muhammedsari.me/unorthodox-eloquent#tappable-scopes).\n\nI am aware that the previous blog post didn''t do justice to how amazing [Tappable scopes](https://muhammedsari.me/unorthodox-eloquent#tappable-scopes) *really* are. Unfortunately, it''s quite a challenging and daunting task to go into every nitty gritty detail when writing long form articles. So, if you''d like to learn more about [Tappable scopes](https://muhammedsari.me/unorthodox-eloquent#tappable-scopes), please check out Marco''s article:\n\n> [Pushing the boundaries of Eloquent](https://blog.deleu.dev/pushing-the-boundaries-of-eloquent)\n\n## Summary\n\nIn all honesty, I still have many other tricks up my sleeve. However, those are even more esoteric than the ones highlighted in this blog post, so I think that''ll be it from me for today. The one point I really want to get across is the fact that curiosity is the key to unlocking new methodologies, perspectives, approaches, and habits. Even if you''ve been using the same thing for a long time now, don''t hesitate to experiment and see if you can improve your current habits. Perfection does not exist, but refinement is something that is always, always possible.\n\n[Join the discussion on X (formerly Twitter)!](https://twitter.com/mabdullahsari/status/1720466260910051502) I''d love to know what you thought about this blog post.\n\nThanks for reading!','\n',char(10)),'I''ve been working with Eloquent for over half a decade now, and it''s time to share my next bag of tricks. You are guaranteed to learn something new!','published','2023-11-03 15:41:33','2023-09-22 17:35:37','2024-01-12 09:18:58');
INSERT INTO blogging_posts VALUES(5,1,'hands-on-decoration','Hands-on decoration',replace('[The Decorator design pattern](https://refactoring.guru/design-patterns/decorator), featured in [the original book by the Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns), captivates me the most among all the discussed patterns. Its simplicity and power (i.e. wide-ranging use / applicability) makes it my personal favorite. \n\nThis simplicity and usefulness, however, is often overlooked and instead the focal points are shifted to "Oh, nice over-engineering" or "Premature abstraction is the root of all evil!" (because there''s an interface in use). While I''m not claiming these are never the case, I think that it''d be fair to say it is flagrantly inequitable to tar every single use case and implementation out there with the same brush. Additionally, the [Laravel documentation on service decoration](https://laravel.com/docs/10.x/container#extending-bindings) is — in my opinion — way too concise.\n\nThat''s why, in this blog post, I''d like to shed some clearer light on this underdog within the Laravel community and provide a *practical example* instead of displaying made-up scenarios. The only prerequisite is to set aside any prejudices you might have regarding decorators whilst also possessing a clear and open mind. I''m not claiming to be the sharpest tool in the shed, though I do believe that I have a superb, practical example waiting for you.\n\n*This blog post assumes that you have at least some familiarity with the decorator design pattern. If you don''t, then I highly recommend that you check out [this write-up by Doeke Norg](https://doeken.org/blog/decorator-vs-proxy-pattern) first before continuing.*\n\n## Case study\n\nWhile working on a side project of mine, I needed the ability to dispatch and display toast messages. You know, those petty alert messages that appear in the corner of your screen. Like always, since this is a pretty generic problem, I started looking at various package directories to see whether someone had built something in Livewire already. I was definitely not disappointed as there were tons of packages. After having had a thorough look at each and every package, though, I unfortunately came to the conclusion that none of them simultaneously checked all of my criteria:\n\n* Not bloated — Huge problem with popular packages.\n* Performant — No additional requests needed. Some always flash to the session, and thus incur slight performance penalties.\n* Smart — No need to explicitly tell if it needs to be an event dispatch or a session flash: the library should figure it out itself. It should also keep the toasts a tiny bit longer on the screen if the textual content is a bit too much to read in e.g. 3 seconds.\n* Effortless in use — No need to remember an explicit `send` call.\n* Top notch DX — Lots of apps are multi-locale, so no need to explicitly call `__` or `Lang::get`.\n* Minimalist design — No intrusive icons, action buttons etc. It should do one job and do it well: display toast messages.\n\nSince such a package did not exist, I decided to bring it into life! I hereby present: [**Livewire Toaster**](https://github.com/masmerise/livewire-toaster).\n(Creative name, isn''t it? You should definitely hire me for your branding needs 😄).\n\nI''d like to zoom into the third and fifth bullet points: *Smart* and *Top notch DX*. In order to make these happen, I made use of snazzy decorators. You must have also heard about the [Open-closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle), right? You know, the [O](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) in [SOLID](https://en.wikipedia.org/wiki/SOLID). By using decorators, it was possible to design the code this way so future extensions are a piece of cake. \n\nThis characteristic came as a mere *bonus* thanks to the modelling approach because it was *not the goal* in and of itself. Please use recipes and tools as an objective compass to guide you in the right direction. The compass itself is not the goal, the goal is the destination!\n\n## Laravel''s `extend` method\n\nBefore moving on to the actual implementation with some code examples, we first need to establish a common understanding with regards to the `Container`s `extend` method and its designated role. I have seen plenty of examples that use this functionality, but unfortunately for the wrong reasons (IMHO). [From the docs](https://laravel.com/docs/10.x/container#extending-bindings), verbatim:\n\n> For example, when a service is resolved, you may run additional code to decorate or configure the service.\n\nUnfortunately, all of them focused on this last bit:\n\n> (...) configure the service.\n\nThere''s a much better way to achieve this goal: [**Container Events**](https://laravel.com/docs/10.x/container#container-events). It makes much more sense to do some additional configuration in a `$this->app->resolving(...)` call because they''re literally designed for this very purpose. [Here''s an example from Inertia that uses the `afterResolving` event](https://github.com/inertiajs/inertia-laravel/pull/395) (`callAfterResolving` is an alias):\n\n```php\n$this->callAfterResolving(''blade.compiler'', function ($blade) {\n    $blade->directive(''inertia'', [Directive::class, ''compile'']);\n    $blade->directive(''inertiaHead'', [Directive::class, ''compileHead'']);\n});\n```\n\nGoing back to the `$this->app->extend(...)` method, I think it''s much easier to remember its true purpose by thinking of it as "extending the behavior". Setting a property on a resolved object does not necessarily "extend the behavior"; it''s more configuration work.\n\n### A "good" example\n\nFor example, have you ever created a package and had a need to "extend" (read: configure) Laravel''s `ExceptionHandler`? You could choose to go down this decoration path:\n\n```php\n$this->app->extend(ExceptionHandler::class, fn ($next) => new Handler($next));\n```\n\nand do something like this:\n\n```php\nfinal class Handler implements ExceptionHandler\n{\n    private ExceptionHandler $handler;\n\n    public function __construct(\n        private ExceptionHandler $handler,\n    ) {}\n\n    public function render($request, Throwable $e): mixed\n    {\n        if ($e instanceof ModelNotFoundException) {\n            // do something...\n        }\n\n        return $this->handler->render($request, $e);\n    }\n\n    // omitted for brevity\n}\n```\n\nI''d argue that this is the lesser option, and using [**Container Events**](https://laravel.com/docs/10.x/container#container-events) is a much better alternative:\n\n```php\n$this->callAfterResolving(ExceptionHandler::class, function (ExceptionHandler $handler) {\n    $handler->ignore(SucceededException::class);\n    $handler->renderable(fn (SucceededException $e) => $this->app->make(Responder::class)->respond());\n});\n```\n\nI hope this makes sense to you. Now let''s get to work!\n\n## Designing the package\n\n[🔗 **Livewire Toaster**](https://github.com/masmerise/livewire-toaster)\n\nThe first thing that you should almost always do when developing a new feature / package / functionality is *experimenting* and thinking about the design / models. You might be under the impression that the current state of the package was there from day 0, but nothing could be further from the truth. I think it took me 2-3 weeks to nail the design of the package so I could implement all of the (self-imposed) requirements and pave the path for future additions. \n\n### Thought process\n\nI sat down and started thinking about how I''d need to tackle the various problems. To make a long story short, after considering all the requirements and connecting all the dots (and after three rewrites), I decided that I needed multiple components to solve the puzzle:\n\n* `Toaster` — The piece responsible for managing and dispatching the toasts.\n* `Toast` — We need to dispatch a toast, after all.\n* `Relay` — Multiple implementations to relay toast messages to the right channels, according to what fits best in the current context.\n* `Hub` - Front-end component that should display the incoming toasts.\n* `Collector` — The central actor whose role is to collect toast messages and then release them on request. This is important because there are multiple `Relay` components as we have just discovered. We are going to focus on this one primarily.\n* There are other fine-grained components, but they''re not really relevant to make our point here. You can always check out [the GitHub repository](https://github.com/masmerise/livewire-toaster) if you''d like to learn more.\n\nThese components all work in tandem to achieve the bigger goal: dispatching and displaying *multiple* toast messages.\n\n### Collector\n\nAs we''ve already learned, this piece sits in the middle of the spectacle and its job is to collect toast messages and then release them when requested. Let''s bring this concept to life:\n\n```php\ninterface Collector\n{\n    public function collect(Toast $toast): void;\n\n    public function release(): array;\n}\n```\n\nBrilliant. We are 50% done already, no kidding. After having defined this *abstract* model, we need something *concrete* to represent it. The specific way in which the `Collector` actually collects those `Toast` messages is an implementation detail. The simplest design I could come up with is a `QueuingCollector`:\n\n```php\nfinal class QueuingCollector implements Collector\n{\n    private array $toasts = [];\n\n    public function collect(Toast $toast): void\n    {\n        $this->toasts[] = $toast;\n    }\n\n    public function release(): array\n    {\n        $toasts = $this->toasts;\n        $this->toasts = [];\n\n        return $toasts;\n    }\n}\n```\n\nIt is called this way, because that''s exactly what it does: it enqueues toast messages using a [Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))-like data structure. This is going to be our main concretion for our abstract model. Next, we need to register it in the service container:\n\n```php\npublic function register(): void\n{\n    $this->app->scoped(Collector::class, QueuingCollector::class);\n}\n```\n\nAre we done? Well, kind of. We still need to enhance the bare minimum functionality and add the behavioral flavors on top.\n\n## Decoration elation\n\n### Smart\n\nThe package needs to be smart, in that it should keep the messages a tad longer on-screen if the messages themselves are longer in nature as well. I have yet to come across a human being that can read 300 words in 3 seconds. This entails the *accessibility* aspect of the toast messages, so calling this an `AccessibleCollector` would be perfect:\n\n```php\nfinal readonly class AccessibleCollector implements Collector\n{\n    private const AMOUNT_OF_WORDS = 100;\n    private const ONE_SECOND = 1000;\n\n    public function __construct(private Collector $next) {}\n\n    public function collect(Toast $toast): void\n    {\n        $addend = (int) floor(str_word_count($toast->message->value) / self::AMOUNT_OF_WORDS);\n        $addend = $addend * self::ONE_SECOND;\n\n        if ($addend > 0) {\n            $toast = ToastBuilder::proto($toast)->duration($toast->duration->value + $addend)->get();\n        }\n\n        $this->next->collect($toast);\n    }\n\n    public function release(): array\n    {\n        return $this->next->release();\n    }\n}\n```\n\nThe code itself is not that relevant, but essentialy what it does is add additional on-screen time for every 100th word in the message. There are a few things to remark on here:\n\n- We are accepting another `Collector` instance, as this is very typical for decorators. In the end, we will obtain an "onion structure".\n- Not everything has to be altered when decorating. In this case, it''s only the `collect` method that''s being decorated. We don''t need to extend the behavior of the `release` method.\n- There is no inheritance. This is composition 101.\n- `final readonly` is my default.\n\n### Top notch DX\n\nI dread this syntax (pseudocode):\n\n```php\nToast::create()\n    ->error(__(''general.obvious.translation''))\n    ->send();\n```\n\nWe could be doing much better:\n\n```php\nToaster::error(''general.obvious.translation'');\n```\n\nAnd with the decorators now in place, this is trivial to implement. Since this entails the translation aspect of the toast messages, the name `TranslatingCollector` would be perfect:\n\n```php\nfinal readonly class TranslatingCollector implements Collector\n{\n    public function __construct(\n        private Collector $next,\n        private Translator $translator,\n    ) {}\n\n    public function collect(Toast $toast): void\n    {\n        $replacement = $this->translator->get($original = $toast->message->value, $toast->message->replace);\n\n        if (is_string($replacement) && $replacement !== $original) {\n            $toast = ToastBuilder::proto($toast)->message($replacement)->get();\n        }\n\n        $this->next->collect($toast);\n    }\n\n    public function release(): array\n    {\n        return $this->next->release();\n    }\n}\n```\n\nAgain, the code itself is not that relevant, but what it does is query the translator and check if the original message got replaced with a new one. If it did change, the original `Toast` gets replaced with a new one and is then forwarded to the next object. I love composition.\n\n### Addendum: Effortless in use\n\nEagle-eyed readers may have noticed that this piece of code does not solve the required, explicit `->send()` calls. It has nothing to do with decoration, but rather with the lifecycle of an object. For this, I created a wrapper `PendingToast` class that wraps the `ToastBuilder`, and automatically dispatches it whenever the object is about to go out of scope:\n\n```php\npublic function __destruct()\n{\n    if (! $this->dispatched) {\n        $this->dispatch();\n    }\n}\n```\n\nMagic? Sure it is, but that''s some good magic. Give me more of it.\n\n### Tying everything together\n\nEvidently, these decorators won''t be doing anything unless we register them with the service container using the `extend` method:\n\n```php\npublic function register(): void\n{\n    $this->app->scoped(Collector::class, QueuingCollector::class);\n\n    $this->app->extend(Collector::class, static fn (Collector $next) => new AccessibleCollector($next));\n    $this->app->extend(Collector::class, fn (Collector $next) => new TranslatingCollector($next, $this->app[''translator'']));\n}\n```\n\nEt voilà. We are done... but are we really? What about providing the package users with the ability to toggle certain features? That would be hard, right? Wrong!\n\nLet''s define a few flags in the configuration file:\n\n```php\nreturn [\n\n    /**\n     * Add an additional second for every 100th word of the toast messages.\n     *\n     * Supported: true | false\n     */\n    ''accessibility'' => true,\n\n    /**\n     * Whether messages passed as translation keys should be translated automatically.\n     *\n     * Supported: true | false\n     */\n    ''translate'' => true,\n];\n```\n\nThe only thing remaining now is to add simple if-checks (disregard the slightly [unconventional config object](https://stitcher.io/blog/what-about-config-builders)):\n\n```php\npublic function register(): void\n{\n    $config = $this->configureService();\n\n    $this->app->scoped(Collector::class, QueuingCollector::class);\n\n    if ($config->wantsAccessibility) {\n        $this->app->extend(Collector::class, static fn (Collector $next) => new AccessibleCollector($next));\n    }\n\n    if ($config->wantsTranslation) {\n        $this->app->extend(Collector::class, fn (Collector $next) => new TranslatingCollector($next, $this->app[''translator'']));\n    }\n}\n```\n\nAaand we are done. I hope you were blown away by the mere simplicity & flexibility of this approach. What''s even more remarkable is the fact that besides making use of the decorator pattern, we have also set up a custom [`Middleware` / `Pipeline`](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern). The responsibilities go like this (very last registration becomes the outer layer of the "onion"):\n\n`Toast` \n→ `TranslatingCollector` \n→ `AccessibleCollector` \n→ `QueuingCollector`\n\nThe `Toast` object goes through a series of layers / pipes before reaching its destination, which is the `QueuingCollector`. Now imagine that new feature requests come in, or we see points of improvement. Extending the functionality / behavior is child''s play:\n\n`Toast` \n→ `ChatGptCollector` \n→ `TranslatingCollector` \n→ `BroadcastingCollector` \n→ `QueuingCollector`\n\nWhat happened to the `AccessibleCollector`?.. Don''t worry. The package user decided to turn that feature off. 😏\n\n## Final words\n\n- Conditionals in code are unavoidable. However, we can place them so high that they almost "fall off". The earlier those conditionals get applied, the less complexity in the resulting code. Composition is the perfect fit for this.\n- There is no single use case for a design pattern. Your creativity is the only limiting factor here. I still remember my college days at Ghent University where they gave silly coffee examples to explain decorators. Looking back at that lecture now, I just have to cringe at how contrived that example was. Contrast that to a real-world example like this...\n- Decorators can be applied as a [Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility). This is noticeable by the `$next` parameter usage.\n- `$this->app->extend` deserves way, way more love and affection. \n- [SOLID is a good tool to have](https://www.youtube.com/watch?v=rtmFCcjEgEw).\n- Behavioral composition is always going to triumph over data-centric thinking. I can''t stress enough how trivial it is to add additional functionality to the package while keeping everything else intact.\n- Proper design is key.\n- Also, please don''t forget to star [Livewire Toaster](https://github.com/masmerise/livewire-toaster). 🙌\n\n[Join the discussion on X (formerly Twitter)!](https://twitter.com/mabdullahsari/status/1725458882292498768) I''d love to know what you thought about this blog post.\n\nThanks for reading!','\n',char(10)),'Mastering elation with the decorator foundation! Let''s take a look at how we can leverage this simple, yet powerful design pattern in the context of a Laravel package.','published','2023-11-17 10:20:28','2023-11-12 18:14:04','2023-11-17 10:20:29');
CREATE TABLE IF NOT EXISTS "blogging_tags" ("id" integer primary key autoincrement not null, "slug" varchar not null, "name" varchar not null);
INSERT INTO blogging_tags VALUES(1,'css','CSS');
INSERT INTO blogging_tags VALUES(2,'javascript','JavaScript');
INSERT INTO blogging_tags VALUES(3,'laravel','Laravel');
INSERT INTO blogging_tags VALUES(4,'php','PHP');
INSERT INTO blogging_tags VALUES(5,'react','React');
INSERT INTO blogging_tags VALUES(6,'tailwind','Tailwind');
INSERT INTO blogging_tags VALUES(7,'patterns','Patterns');
CREATE TABLE IF NOT EXISTS "blogging_post_tag" ("post_id" integer not null, "tag_id" integer not null, foreign key("post_id") references "blogging_posts"("id") on delete cascade on update cascade, foreign key("tag_id") references "blogging_tags"("id") on delete cascade on update cascade, primary key ("post_id", "tag_id"));
INSERT INTO blogging_post_tag VALUES(1,4);
INSERT INTO blogging_post_tag VALUES(1,3);
INSERT INTO blogging_post_tag VALUES(2,3);
INSERT INTO blogging_post_tag VALUES(2,4);
INSERT INTO blogging_post_tag VALUES(2,7);
INSERT INTO blogging_post_tag VALUES(3,3);
INSERT INTO blogging_post_tag VALUES(3,4);
INSERT INTO blogging_post_tag VALUES(4,3);
INSERT INTO blogging_post_tag VALUES(4,4);
INSERT INTO blogging_post_tag VALUES(5,3);
INSERT INTO blogging_post_tag VALUES(5,4);
INSERT INTO blogging_post_tag VALUES(5,7);
COMMIT;
